---
layout:     post
title:      "Java源码系列(9) -- HashMap"
date:       2018-06-24
author:     "phantomVK"
header-img: "img/bg/post_bg.jpg"
catalog:    true
tags:
    - Java源码系列
---

## 一、摘要

HashMap是软件工程师使用最频繁、来保存键值对映射的容器类，没有之一。自JDK8开始，HashMap引入红黑树、优化哈希算法等调整，性能相比JDK7有进一步提升，同时对JDK7中多线程操作导致死循环的问题进行了优化。

不过，优化后HashMap依然线程不安全。本文基于JDK10的HashMap源码进行介绍，会对代码格式进行调整以便阅读，最终逻辑与JDK8版本无异。由于HashMap源码较多，本文内容为避免篇幅过长，部分源码不做介绍，有学习需要请自行查阅。

## 二、类签名

假设键值对能正确分散到不用桶中时，访问get()和put()方法的时间消耗可近似为一个时间常数。HashMap的遍历性能与哈希桶(table长度)、Node节点(键值对)数量成比例，因此不宜把初始capacity设置得过大，或把负载因子值load-factor(默认0.75)设置得过小。

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```

作为通用规范，默认负载因子值0.75能非常好地平衡时间开销和内存空间开销之间的关系。高负载因子值(如>0.75)减少内存空间的开支，但是会增加键值对的查找开销。如果能在创建HashMap的时候计算并指定哈希表初始容量，这样做能完全避免后期的重哈希操作，相当于令插入键值对的操作更高效。

![HashMap_UML](/img/java/HashMap_UML.png)

在HashMap的类注释中，有不可忽略的几个技术点： 

- 实现Map<K,V>接口，支持其所有操作；
- HashMap支持null键和null值；
- HashMap线程不安全；

与HashMap一并谈论较多的是HashTable，开发于早期JDK，后来被建议使用HashMap替代。虽然现在后者不多见，但是并不妨碍对两者进行横向比较：

- HashTable不支持键或值为null，而HashMap支持；
- HashTable线程安全，与ConcurrentHashMap一样均适用多线程；
- 均实现Map<K,V>接口，具有基本相当的Map操作能力；
- 均不保证元素写入与读取的元素顺序一致；

上文提到，HashMap本身不是线程安全的，所以可通过
```java
Map m = Collections.synchronizedMap(new HashMap(...));
```
包装实例，或替换为ConcurrentHashMap类保证线程安全。

## 三、常量成员
```java
// HashMap默认初始化大小为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;

// HashMap最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;

// 构造方法默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 从链表转换为红黑树的阀值
static final int TREEIFY_THRESHOLD = 8;

// 从红黑树回到链表的阀值
static final int UNTREEIFY_THRESHOLD = 6;

// 整个哈希表容量超过此值，链表长度超过TREEIFY_THRESHOLD才树化
static final int MIN_TREEIFY_CAPACITY = 64;
```

## 四、数据成员

```java
// 哈希表，长度为2的n次幂，不超过MAXIMUM_CAPACITY；
transient Node<K,V>[] table;

// 保存键值对数量
transient int size;

// 结构性或键值对数量变化总次数。用在'快速失败'，详情参阅ConcurrentModificationException
transient int modCount;

// 	下次表扩容阀值: threshold = capacity * load factor.
int threshold;

// 负载因子值
final float loadFactor;
```

## 五、节点

### 5.1 桶节点

HashMap中有数据成员`Node<K,V>[] table`，里面保存的是内部类`Node<K,V>`，实现`Map.Entry<K,V>`接口。

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash; // 节点哈希值
    final K key;    // 节点键
    V value;        // 节点值
    Node<K,V> next; // 下一个节点引用

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }
    
    // 存入新value后会把旧值oldValue返回
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        // 同一个对象
        if (o == this)
            return true;
        // 检查对象o是否为Map.Entry的子类
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            // 另一个Node的key-value与此Node的一致也算相同
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```

哈希冲突解决方法常用有两种：开放地址法和拉链法。而节点字段`Node<K,V> next`保存下一个节点的引用，由此推断出HashMap用拉链法处理哈希冲突问题。

![HashMap_Node_UML](/img/java/HashMap_Node_UML.png)

从节点源码`final K key;`可知键值一旦指定就不能改变，不然以后会因键哈希值改变而匹配不上。

### 5.2 哈希桶索引计算

通常，判断Hash算法是否高效的方式是看元素是否均匀分放到不同桶中，最好是一个桶存放一个键值对。即时存放更多的元素，也希望每个桶能均衡地放下相同数量。如果哈希算法不佳，导致一个桶中存放的元素数量特别多，会严重影响存取性能。

换个角度，HashMap为了减低碰撞几率，会给HashMap设置一个负载因子 load factor（默认值0.75）。假设用默认桶数量capacity（初始值16），通过threshold = capacity * load factor 计算式可知当键值对数量超过12时会触发桶数量扩容。所以，通过单纯使用大量的桶，即使使用不经优化的哈希算法，也能把元素相对均匀地放在不同桶中，类似空间换时间。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

JDK中的HashMap，经过长期验证和修改，已经能很好地在空间和时间两者间取得平衡。

以前，当桶数量较少时，连续值经过哈希运算，很容易被分配到相同的桶中导致哈希碰撞。JDK8开把哈希值高16位与低16位进行亦或运算。在不减低性能的前提下充分利用有限的条件，提高混淆度，尽量把元素分配到不用的桶中。

![HashMap_bit_hashCode](/img/java/HashMap_bit_hashCode.png)

这种方式以下好处：

* 满足速度、功效、位分散质量等条件；
* 避免使用%操作的同时，让位运算发挥更好效果；
* 避免性能损耗，开销较低

### 5.3 计算哈希表大小

通过给定数值计算得相等或更大，且大小为2^n数值。

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

下面假设cap大小为15，通过`tableSizeFor()`计算的图示：

![HashMap_tableSizeFor](/img/java/HashMap_tableSizeFor.png)

从图中看出，当流程进行到`n|=n>>>4`，后续步骤运算结果已经固定不改变。

## 六、成员方法

### 6.1 构造方法

```java
// 指定初始容量值和负载因子值
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

// 指定初始容量值，并使用默认负载因子值0.75。注意，初始容量值只能为非负数。
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

// 构造空的HashMap，默认初始容量为16，默认负载因子为0.75。其他参数使用默认值
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
}

// 通过给定Map创建新的HashMap。负载因子默认为0.75，容量值为足够保存m中键值对大小；
// 若m为null会抛出NullPointerException
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
```

### 6.2 查询
```java
final Node<K,V> getNode(int hash, Object key) {
    // tab: 哈希表
    // first: 桶内首节点
    // n: 哈希桶索引
    // k: 临时Node变量
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;

    if ((tab = table) != null
        && (n = tab.length) > 0
        && (first = tab[(n - 1) & hash]) != null) {
        // 检查桶内首节点是否匹配
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;

        // 查找桶内其他节点
        if ((e = first.next) != null) {
            // 桶内节点以红黑树的方式保存，用红黑树的方法查找节点
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            
            // 桶内节点以链表的方式保存，遍历链表查找节点
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    
    // 哈希表没有元素，或没有找到对应Node
    return null;
}

// 返回key对应的value，若key内有对应映射，则返回null
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

// 查询是否包含该键对应的值
public boolean containsKey(Object key) {
    return getNode(hash(key), key) != null;
}
```

### 6.3 插入

```java
// @param onlyIfAbsent 为 true, 不会改变已有值
// @param evict 为 false, 哈希表正处于创建模式
final V putVal(int hash,
               K key, V value,
               boolean onlyIfAbsent,
               boolean evict) {
    // tab: 局部变量哈希表，即HashMap.table[];
    // n: 哈希表长度，即tab[].length;
    // i: 哈希桶索引，即(n - 1) & hash;
    // p: 哈希桶首Node，即tab[i]
    Node<K,V>[] tab; Node<K,V> p; int n, i;

    // table为null 或 table.length == 0，构建新哈希表
    if ((tab = table) == null || (n = tab.length) == 0)
        // resize()里新哈希表会在方法内赋值给table，后返回哈希表引用并赋值给tab
        n = (tab = resize()).length;

    // 通过hash值确定哈希桶
    if ((p = tab[i = (n - 1) & hash]) == null)
        // table[index]为null，创建新Node并放入数组该位置
        tab[i] = newNode(hash, key, value, null);
    else {
        // table[index]不为null，表示桶内已有至少一个Node
        // e: 临时保存节点
        // k: 桶首节点哈希值
        Node<K,V> e; K k;
        
        // 确定节点p.key哈希与插入节点k.key哈希是否相同
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode) // 桶首节点继承自TreeNode，后续节点以红黑树存放
            // 调用红黑树的putTreeVal()
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 把节点插入到哈希桶链表队尾，FIFO；JDK7或之前版本是头插法
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 创建新节点，尾插法保存到链表尾
                    p.next = newNode(hash, key, value, null);

                    // 桶内节点数超过TREEIFY_THRESHOLD，需要转为红黑树，并退出迭代                
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }

                // 找到key完全相同的节点，表明需要替换此节点的value，而不是新生成节点
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;

                p = e;
            }
        }

        // 相同key已有olbValue存在
        if (e != null) {
            V oldValue = e.value;
            
            // onlyIfAbsent为true，当存在oldValue映射到key就不用newValue替换
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;

            afterNodeAccess(e);
            
            // 返回已存在value，若value不存在则返回值为null
            return oldValue;
        }
    }

    // 增加修改次数
    ++modCount;

    // 已保存元素数量超过阀值需扩容哈希表
    if (++size > threshold)
        resize();

    afterNodeInsertion(evict);
    return null;
}

// 存入键值对，若此前已存在一个键值对，会返回上一个值，否则返回null
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

### 6.4 批量插入

```java
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    // m为null会导致NullPointerException
    int s = m.size();

    if (s > 0) {
        if (table == null) {
            // 如果本HashMap为null，用m的大小决定本HashMap的初始大小
            float ft = ((float)s / loadFactor) + 1.0F;

            // 检查是否超过大小限制
            int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);

            // 向上规整
            if (t > threshold)
                threshold = tableSizeFor(t);
        }
        else if (s > threshold) {
            // 本HashMap为null，执行扩容
            resize();
        }
        
        // 依次遍历m的节点，存入本HashMap
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            // onlyIfAbsent为false
            putVal(hash(key), key, value, false, evict);
        }
    }
}

public void putAll(Map<? extends K, ? extends V> m) {
    putMapEntries(m, true);
}
```

### 6.5 扩容

当哈希表已保存元素数量超过`DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY`，通过此方法扩大哈希表容量，大小只会向容量更大的方向演进。

每次扩容都会增大table的长度，并且已有节点都需重哈希，保证元素放入正新的哈希桶内。

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table; // 保存旧哈希表
    int oldCap = (oldTab == null) ? 0 : oldTab.length; // 保存旧哈希表长度
    int oldThr = threshold; // 保存旧扩容阀值
    int newCap, newThr = 0;

    if (oldCap > 0) {
        // 超过元素数量最大上限
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY) {
            // 扩充为原来两倍: 左移原值乘以2，右移原值除以2
            newThr = oldThr << 1;
        }
    } else if (oldThr > 0) {
        // 哈希表没有创建，但是已设定扩容阀值，则用该阀值去初始化
        newCap = oldThr;
    } else {
        // oldCap == 0 && oldThr == 0
        // 哈希表即没有初始化，也没有设置初始阀值，则通过默认值进行初始化
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
   
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    
    threshold = newThr;
    
    // 创建新哈希表
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    
    // 把旧表的元素全部重哈希到新表
    if (oldTab != null) {
        // 依次处理旧哈希表的哈希桶
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null; // 把链表或红黑树从旧表解链接
                
                // 桶内只有一个元素
                if (e.next == null) {
                    // 在新哈希表中给元素e选桶
                    newTab[e.hash & (newCap - 1)] = e;
                } else if (e instanceof TreeNode) {
                    // 把红黑树的元素重哈希到新表
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                } else { // preserve order
                    // 桶内有多个元素且结构为链表，使用以下优化算法:
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null) {
                                // 低位新哈希桶的首个元素，e既赋值给loHead，又赋值给loTail
                                loHead = e;
                            } else {
                                // 低位新哈希桶的后续元素，接到loTail的下一个位置上
                                loTail.next = e;
                            }

                            // 若是低位新哈希桶的首个元素，e既赋值给loHead，又赋值给loTail
                            loTail = e;
                        }
                        else {
                            if (hiTail == null) {
                                // 高位新哈希桶的首个元素，e既赋值给hiHead，又赋值给hiTail
                                hiHead = e;
                            } else {
                                // 高位新哈希桶的后续元素，接到hiTail的下一个位置上
                                hiTail.next = e
                            }

                            // 若是高位新哈希桶的首个元素，e既赋值给hiHead，又赋值给hiTail；
                            hiTail = e;
                        }
                    } while ((e = next) != null);

                    // 放到低位哈希桶
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }

                    // 放到高位哈希桶
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    
    // 扩容完毕，返回新哈希表
    return newTab;
}
```

下面举例一个旧表：
 * 第一行是数值`oldCap`，这个例子是4；
 * 第二行是每个数值的`e.hash`；
 * 第三行是位运算`e.hash & oldCap) == 0`得出红色数字；

![HashMap_oldMap](/img/java/HashMap_oldMap.png)

扩容后的新表，对比旧表中的数字：位运算为`0`的放在原桶索引位置`oldIndex`，位运算为`1`的放在新桶索引位置`oldIndex+oldCap`
![HashMap_newMap](/img/java/HashMap_newMap.png)

于是从运算前旧表`oldCap`为4换新表`newCap`为8，且元素全部经过重哈希放入新桶中：

![HashMap_resize](/img/java/HashMap_resize.png)

### 6.6 树化节点

把链表转换为红黑树：首先把链表的节点更换为红黑树节点，然后把整条链变形为红黑树

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    // 链表长度不超过MIN_TREEIFY_CAPACITY，则仅进行扩容，不转换为红黑树
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        // 头结点hd，尾节点tl
        TreeNode<K,V> hd = null, tl = null;
        do {
            // 更换链表节点为红黑树节点
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        
        // 头节点非空，转换链表为红黑树
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
```

### 6.7 删除

```java
// * @param value the value to match if matchValue, else ignored
// * @param matchValue if true only remove if value is equal
// * @param movable if false do not move other nodes while removing
final Node<K,V> removeNode(int hash,
                           Object key, Object value,
                           boolean matchValue,
                           boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    // 哈希表不为null，且桶首节点不为null
    if ((tab = table) != null
        && (n = tab.length) > 0
        && (p = tab[index = (n - 1) & hash]) != null) {
        Node<K,V> node = null, e; K k; V v;
        
        // 匹配桶首节点
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            // 遍历红黑树
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                // 遍历链表
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        
        // 遍历节点不为空，则找到目标节点
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode) {
                // 节点为红黑树，通过红黑树的方式移除节点
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            } else if (node == p) {
                // 匹配为链表的桶首节点，直接把链表第二个节点替换其位置
                tab[index] = node.next;
            } else {
                // 非链表头结点元素
                p.next = node.next;
            }
            // 哈希表修改次数加一
            ++modCount;

            // 移除一个元素
            --size;

            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}

public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```
### 6.8 清空

把桶首节点元素与哈希表解链接，桶内的链表或红黑树由虚拟机进行垃圾回收

```java
public void clear() {
    Node<K,V>[] tab;
    modCount++;
    if ((tab = table) != null && size > 0) {
        // 以保存元素数量复位
        size = 0;
        // 链表或红黑树与哈希表解除连接
        for (int i = 0; i < tab.length; ++i)
            tab[i] = null;
    }
}
```

### 6.9 包含

```java
public boolean containsValue(Object value) {
    Node<K,V>[] tab; V v;
    if ((tab = table) != null && size > 0) {
        // 依次遍历每个哈希桶
        for (Node<K,V> e : tab) {
            // 遍历哈希桶内所有节点
            for (; e != null; e = e.next) {
                // 查找是否存在保存了该value的节点e
                if ((v = e.value) == value ||
                    (value != null && value.equals(v)))
                    return true;
            }
        }
    }
    
    // 哈希表为空，或没有找到匹配键值对
    return false;
}
```

### 6.10 计算容量

```java
final int capacity() {
    return (table != null) ? table.length :
        (threshold > 0) ? threshold :
        DEFAULT_INITIAL_CAPACITY;
}
```

## 七、红黑树节点

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V>
```

![HashMap_TreeNode_UML](/img/java/HashMap_TreeNode_UML.png)

### 7.1 节点数据成员
```java
TreeNode<K,V> parent;  // 父节点
TreeNode<K,V> left; // 左子树
TreeNode<K,V> right; // 右子树
TreeNode<K,V> prev;    // needed to unlink next upon deletion
boolean red; // 节点颜色: 红色或黑色

// 构造方法
TreeNode(int hash, K key, V val, Node<K,V> next) {
    super(hash, key, val, next);
}
```

### 7.2 获取根节点

返回指定节点所在红黑树的根节点，沿着TreeNode.parent遍历到根节点

```java
final TreeNode<K,V> root() {
    for (TreeNode<K,V> r = this, p;;) {
        if ((p = r.parent) == null)
            return r;
        r = p;
    }
}
```

### 7.3 移动根节点

保证树的根节点一定是链表的首节点

```java
static <K,V> void moveRootToFront(Node<K,V>[] tab, TreeNode<K,V> root) {
    int n;

    // 根节点非空、哈希表不为空、桶首节点不为空
    if (root != null && tab != null && (n = tab.length) > 0) {
        // 根据哈希值查哈希桶
        int index = (n - 1) & root.hash;
        // 获取桶首元素
        TreeNode<K,V> first = (TreeNode<K,V>)tab[index];
        
        // 桶首元素不是红黑树的根节点，则开始移动节点
        if (root != first) {
            Node<K,V> rn; // eq. root.next
            tab[index] = root; // 根节点赋值为桶首元素
            TreeNode<K,V> rp = root.prev; // 根节点的前一个节点

            // root.next不为空，把root.prev赋值给root.next.prev，相当于把root节点解除链接
            if ((rn = root.next) != null)
                ((TreeNode<K,V>)rn).prev = rp;
            
            // 根节点的前一个节点不为空，把前一个节点的next指针指向根节点的下一个节点
            if (rp != null)
                rp.next = rn;
            
            // 桶首节点不为空，把根节点作为桶首节点的上一个节点
            if (first != null)
                first.prev = root;
            
            // 原桶首节点现在作为root的一个节点
            root.next = first;
            // 首节点没有前节点
            root.prev = null;
        }
        // 检查处理后的红黑树书否符合标准
        assert checkInvariants(root);
    }
}
```


### 7.4 查找节点

```java
final TreeNode<K,V> find(int h, Object k, Class<?> kc) {
    TreeNode<K,V> p = this;
    do {
        int ph, dir; K pk;
        TreeNode<K,V> pl = p.left, pr = p.right, q;
        if ((ph = p.hash) > h)
            p = pl;
        else if (ph < h)
            p = pr;
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        else if (pl == null)
            p = pr;
        else if (pr == null)
            p = pl;
        else if ((kc != null ||
                  (kc = comparableClassFor(k)) != null) &&
                 (dir = compareComparables(kc, k, pk)) != 0)
            p = (dir < 0) ? pl : pr;
        else if ((q = pr.find(h, k, kc)) != null)
            return q;
        else
            p = pl;
    } while (p != null);
    return null;
}

final TreeNode<K,V> getTreeNode(int h, Object k) {
    return ((parent != null) ? root() : this).find(h, k, null);
}
```

### 7.5 大小比较 

节点的键没有实现`Comparable`接口，或键通过`compareTo`比较相同时，需要通过此方法比较大小

```java
static int tieBreakOrder(Object a, Object b) {
    int d;
    if (a == null || b == null ||
        (d = a.getClass().getName().
         compareTo(b.getClass().getName())) == 0) // 通过类名进行compareTo比较，不同则用此结果
        // a为null，或b为null，或两个对象类名对比相同，就用hashCode值比较，小于等于返回-1，否则返回1
        d = (System.identityHashCode(a) <= System.identityHashCode(b) ?
             -1 : 1);
    return d;
}
```

### 7.6 构建红黑树

```java
final void treeify(Node<K,V>[] tab) {
    // 根节点
    TreeNode<K,V> root = null;

    for (TreeNode<K,V> x = this, next; x != null; x = next) {
        // 正在遍历节点的下一个节点
        next = (TreeNode<K,V>)x.next;
        x.left = x.right = null;
        
        // 根节点为空，把当前节点作为根节点，且节点颜色为黑色
        if (root == null) {
            x.parent = null;
            x.red = false;
            root = x;
        }
        else { // 存在根节点
            K k = x.key;
            int h = x.hash;
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph;
                K pk = p.key;
                if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0)
                    dir = tieBreakOrder(k, pk);

                TreeNode<K,V> xp = p;
                if ((p = (dir <= 0) ? p.left : p.right) == null) {
                    x.parent = xp;
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    root = balanceInsertion(root, x);
                    break;
                }
            }
        }
    }
    moveRootToFront(tab, root);
}
```

### 7.7 去树化

把红黑树转换为链表形式

```java
final Node<K,V> untreeify(HashMap<K,V> map) {
    // 链表头指针hd，链表尾指针tl
    Node<K,V> hd = null, tl = null;

    for (Node<K,V> q = this; q != null; q = q.next) {
        // 把红黑树节点更换为普通链表节点
        Node<K,V> p = map.replacementNode(q, null);
        // 然后把所有节点按照遍历的顺序依次串起来
        if (tl == null)
            hd = p;
        else
            tl.next = p;
        tl = p;
    }
    // 返回一条链表
    return hd;
}
```

### 7.8 插入树节点

```java
final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,
                               int h, K k, V v) {
    Class<?> kc = null;
    boolean searched = false;
    TreeNode<K,V> root = (parent != null) ? root() : this;
    for (TreeNode<K,V> p = root;;) {
        int dir, ph; K pk;
        if ((ph = p.hash) > h)
            dir = -1;
        else if (ph < h)
            dir = 1;
        else if ((pk = p.key) == k || (k != null && k.equals(pk)))
            return p;
        else if ((kc == null &&
                  (kc = comparableClassFor(k)) == null) ||
                 (dir = compareComparables(kc, k, pk)) == 0) {
            if (!searched) {
                TreeNode<K,V> q, ch;
                searched = true;
                if (((ch = p.left) != null &&
                     (q = ch.find(h, k, kc)) != null) ||
                    ((ch = p.right) != null &&
                     (q = ch.find(h, k, kc)) != null))
                    return q;
            }
            dir = tieBreakOrder(k, pk);
        }

        TreeNode<K,V> xp = p;
        if ((p = (dir <= 0) ? p.left : p.right) == null) {
            Node<K,V> xpn = xp.next;
            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);
            if (dir <= 0)
                xp.left = x;
            else
                xp.right = x;
            xp.next = x;
            x.parent = x.prev = xp;
            if (xpn != null)
                ((TreeNode<K,V>)xpn).prev = x;
            moveRootToFront(tab, balanceInsertion(root, x));
            return null;
        }
    }
}
```

### 7.9 移除树节点

```java
/**
 * Removes the given node, that must be present before this call.
 * This is messier than typical red-black deletion code because we
 * cannot swap the contents of an interior node with a leaf
 * successor that is pinned by "next" pointers that are accessible
 * independently during traversal. So instead we swap the tree
 * linkages. If the current tree appears to have too few nodes,
 * the bin is converted back to a plain bin. (The test triggers
 * somewhere between 2 and 6 nodes, depending on tree structure).
 */
final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,
                          boolean movable) {
    int n;
    if (tab == null || (n = tab.length) == 0)
        return;
    int index = (n - 1) & hash;
    TreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;
    TreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;
    if (pred == null)
        tab[index] = first = succ;
    else
        pred.next = succ;
    if (succ != null)
        succ.prev = pred;
    if (first == null)
        return;
    if (root.parent != null)
        root = root.root();
    if (root == null
        || (movable
            && (root.right == null
                || (rl = root.left) == null
                || rl.left == null))) {
        tab[index] = first.untreeify(map);  // too small
        return;
    }
    TreeNode<K,V> p = this, pl = left, pr = right, replacement;
    if (pl != null && pr != null) {
        TreeNode<K,V> s = pr, sl;
        while ((sl = s.left) != null) // find successor
            s = sl;
        boolean c = s.red; s.red = p.red; p.red = c; // swap colors
        TreeNode<K,V> sr = s.right;
        TreeNode<K,V> pp = p.parent;
        if (s == pr) { // p was s's direct parent
            p.parent = s;
            s.right = p;
        }
        else {
            TreeNode<K,V> sp = s.parent;
            if ((p.parent = sp) != null) {
                if (s == sp.left)
                    sp.left = p;
                else
                    sp.right = p;
            }
            if ((s.right = pr) != null)
                pr.parent = s;
        }
        p.left = null;
        if ((p.right = sr) != null)
            sr.parent = p;
        if ((s.left = pl) != null)
            pl.parent = s;
        if ((s.parent = pp) == null)
            root = s;
        else if (p == pp.left)
            pp.left = s;
        else
            pp.right = s;
        if (sr != null)
            replacement = sr;
        else
            replacement = p;
    }
    else if (pl != null)
        replacement = pl;
    else if (pr != null)
        replacement = pr;
    else
        replacement = p;
    if (replacement != p) {
        TreeNode<K,V> pp = replacement.parent = p.parent;
        if (pp == null)
            root = replacement;
        else if (p == pp.left)
            pp.left = replacement;
        else
            pp.right = replacement;
        p.left = p.right = p.parent = null;
    }

    TreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);

    if (replacement == p) {  // detach
        TreeNode<K,V> pp = p.parent;
        p.parent = null;
        if (pp != null) {
            if (p == pp.left)
                pp.left = null;
            else if (p == pp.right)
                pp.right = null;
        }
    }
    if (movable)
        moveRootToFront(tab, r);
}
```

### 7.10 分割

```java
/**
 * Splits nodes in a tree bin into lower and upper tree bins,
 * or untreeifies if now too small. Called only from resize;
 * see above discussion about split bits and indices.
 *
 * @param map the map
 * @param tab the table for recording bin heads
 * @param index the index of the table being split
 * @param bit the bit of hash to split on
 */
final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
    TreeNode<K,V> b = this;
    // Relink into lo and hi lists, preserving order
    TreeNode<K,V> loHead = null, loTail = null;
    TreeNode<K,V> hiHead = null, hiTail = null;
    int lc = 0, hc = 0;
    for (TreeNode<K,V> e = b, next; e != null; e = next) {
        next = (TreeNode<K,V>)e.next;
        e.next = null;
        if ((e.hash & bit) == 0) {
            if ((e.prev = loTail) == null)
                loHead = e;
            else
                loTail.next = e;
            loTail = e;
            ++lc;
        }
        else {
            if ((e.prev = hiTail) == null)
                hiHead = e;
            else
                hiTail.next = e;
            hiTail = e;
            ++hc;
        }
    }

    if (loHead != null) {
        if (lc <= UNTREEIFY_THRESHOLD)
            tab[index] = loHead.untreeify(map);
        else {
            tab[index] = loHead;
            if (hiHead != null) // (else is already treeified)
                loHead.treeify(tab);
        }
    }
    if (hiHead != null) {
        if (hc <= UNTREEIFY_THRESHOLD)
            tab[index + bit] = hiHead.untreeify(map);
        else {
            tab[index + bit] = hiHead;
            if (loHead != null)
                hiHead.treeify(tab);
        }
    }
}
```

### 7.11 翻转左子树

```java
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    TreeNode<K,V> r, pp, rl;
    if (p != null && (r = p.right) != null) {
        if ((rl = p.right = r.left) != null)
            rl.parent = p;
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        r.left = p;
        p.parent = r;
    }
    return root;
}
```

### 7.12 翻转右子树

```java
static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,
                                       TreeNode<K,V> p) {
    TreeNode<K,V> l, pp, lr;
    if (p != null && (l = p.left) != null) {
        if ((lr = p.left = l.right) != null)
            lr.parent = p;
        if ((pp = l.parent = p.parent) == null)
            (root = l).red = false;
        else if (pp.right == p)
            pp.right = l;
        else
            pp.left = l;
        l.right = p;
        p.parent = l;
    }
    return root;
}
```

### 7.13 平衡插入

```java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                            TreeNode<K,V> x) {
    // 新插入节点为红节点
    x.red = true;
    for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
        // 节点为根节点，更根据红黑树条件来说，根节点一定为黑色
        if ((xp = x.parent) == null) {
            x.red = false;
            return x;
        }
        else if (!xp.red || (xpp = xp.parent) == null)
            return root;
        if (xp == (xppl = xpp.left)) {
            if ((xppr = xpp.right) != null && xppr.red) {
                xppr.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                // 该节点为父节点的右节点，左旋
                if (x == xp.right) {
                    root = rotateLeft(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                
                // 右旋
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateRight(root, xpp);
                    }
                }
            }
        }
        else {
            if (xppl != null && xppl.red) {
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                if (x == xp.left) {
                    root = rotateRight(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
    }
}
```


### 7.14 平衡删除

```java
static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,
                                           TreeNode<K,V> x) {
    for (TreeNode<K,V> xp, xpl, xpr;;) {
        if (x == null || x == root)
            return root;
        else if ((xp = x.parent) == null) {
            x.red = false;
            return x;
        }
        else if (x.red) {
            x.red = false;
            return root;
        }
        else if ((xpl = xp.left) == x) {
            if ((xpr = xp.right) != null && xpr.red) {
                xpr.red = false;
                xp.red = true;
                root = rotateLeft(root, xp);
                xpr = (xp = x.parent) == null ? null : xp.right;
            }
            if (xpr == null)
                x = xp;
            else {
                TreeNode<K,V> sl = xpr.left, sr = xpr.right;
                if ((sr == null || !sr.red) &&
                    (sl == null || !sl.red)) {
                    xpr.red = true;
                    x = xp;
                }
                else {
                    if (sr == null || !sr.red) {
                        if (sl != null)
                            sl.red = false;
                        xpr.red = true;
                        root = rotateRight(root, xpr);
                        xpr = (xp = x.parent) == null ?
                            null : xp.right;
                    }
                    if (xpr != null) {
                        xpr.red = (xp == null) ? false : xp.red;
                        if ((sr = xpr.right) != null)
                            sr.red = false;
                    }
                    if (xp != null) {
                        xp.red = false;
                        root = rotateLeft(root, xp);
                    }
                    x = root;
                }
            }
        }
        else { // symmetric
            if (xpl != null && xpl.red) {
                xpl.red = false;
                xp.red = true;
                root = rotateRight(root, xp);
                xpl = (xp = x.parent) == null ? null : xp.left;
            }
            if (xpl == null)
                x = xp;
            else {
                TreeNode<K,V> sl = xpl.left, sr = xpl.right;
                if ((sl == null || !sl.red) &&
                    (sr == null || !sr.red)) {
                    xpl.red = true;
                    x = xp;
                }
                else {
                    if (sl == null || !sl.red) {
                        if (sr != null)
                            sr.red = false;
                        xpl.red = true;
                        root = rotateLeft(root, xpl);
                        xpl = (xp = x.parent) == null ?
                            null : xp.left;
                    }
                    if (xpl != null) {
                        xpl.red = (xp == null) ? false : xp.red;
                        if ((sl = xpl.left) != null)
                            sl.red = false;
                    }
                    if (xp != null) {
                        xp.red = false;
                        root = rotateRight(root, xp);
                    }
                    x = root;
                }
            }
        }
    }
}
```

### 7.15 递归检查

```java
static <K,V> boolean checkInvariants(TreeNode<K,V> t) {
    TreeNode<K,V> tp = t.parent, tl = t.left, tr = t.right,
        tb = t.prev, tn = (TreeNode<K,V>)t.next;
    if (tb != null && tb.next != t)
        return false;
    if (tn != null && tn.prev != t)
        return false;
    if (tp != null && t != tp.left && t != tp.right)
        return false;
    if (tl != null && (tl.parent != t || tl.hash > t.hash))
        return false;
    if (tr != null && (tr.parent != t || tr.hash < t.hash))
        return false;
    if (t.red && tl != null && tl.red && tr != null && tr.red)
        return false;
    if (tl != null && !checkInvariants(tl))
        return false;
    if (tr != null && !checkInvariants(tr))
        return false;
    return true;
}
```
## 八、参考链接

* [美团技术团队 -  Java 8系列之重新认识HashMap](https://tech.meituan.com/java-hashmap.html)
* [I-team - 死磕Java之聊聊HashMap源码(基于JDK1.8)](http://www.hchstudio.cn/article/2018/10fc/)
* [StackOverflow - Does HashTable maintains the insertion order?](https://stackoverflow.com/a/6405709/8750399)
* [StackOverflow - Why Hashtable does not allow null keys or values?](https://stackoverflow.com/a/11981897/8750399)
* [知乎 - JoonWhee - HashMap讲解(上)](https://zhuanlan.zhihu.com/p/34361643)
* [CSDN - chenssy - 【死磕Java并发】-----J.U.C之ConcurrentHashMap红黑树转换分析](https://blog.csdn.net/chenssy/article/details/73749297)
