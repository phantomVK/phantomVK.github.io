---
layout:     post
title:      "Android源码系列(6) -- LruCache"
date:       2017-02-28
author:     "phantomVK"
header-img: "img/main_img.jpg"
catalog:    true
tags:
    - Android源码系列
---


## 一、类签名

LruCache是Android提供的缓存工具类，根据最近最少使用算法缓存元素，避免因缓存过多导致内存占用过大，或内存释放不及时引起内存溢出。

```java
public class LruCache<K, V>
```

资源缓存除了最近最少使用外，还巧妙利用Java对象引用类型完成内存回收。这4种类型分别是强、软、弱、虚。

每次被操作的元素都会移动到队列首位，一段时间后，本来处于队列前方的元素因为其他元素的操作逐渐后退到队尾。如果队列空间足够，所有元素都不会移除。否则处于队尾的元素会优先移除，腾出空间容纳新元素。因此使用热度高的资源得到有效缓存，长时间没有使用的资源会被移除队列。

为了使该类适合实际应用，开发中多定义子类继承`LruCache`，重写`create()`、`entryRemoved()`和`sizeOf()`等方法。

## 二、数据成员


`LruCache`通过`LinkedHashMap`数据结构来完成item的保存，无论是查找、节点修改，都能提供不错的性能

```java
private final LinkedHashMap<K, V> map;
```

两个数值分别用来记录`保存容量`及`最大容量`，且前者不大于后者。值得注意的是，这个容量可能是键的个数(针对Key)，也可能是值总体积(针对Value)。例如通过LruCache缓存图片，既可以通过限制图片数量，也可以限制缓存图片容量总大小实现内存管理。

```java
private int size;
private int maxSize;
```

用来保存各种操作统计次数，注释标示的操作会修改对应统计的次数。如：添加一个元素就会给`putCount`增加一次计数。

```java
private int putCount;     // 加入
private int createCount;  // 创建
private int evictionCount;// 舍弃
private int hitCount;     // 查找命中
private int missCount;    // 命中失败
```

## 三、构造方法

`maxSize`记录整个列表最大保存数。为避免严重的哈希冲突，`LinkedHashMap`哈希因子设定为0.75且不能自定义。

`LinkedHashMap`构造函数参数`accessOrder`为`true`时，`LinkedHashMap`以访问顺序排列元素，否则以插入顺序排序元素。从源码可知`LruCache`使用`LinkedHashMap`时`accessOrder`为`true`。

```java
public LruCache(int maxSize) {
    if (maxSize <= 0) {
        throw new IllegalArgumentException("maxSize <= 0");
    }
    this.maxSize = maxSize;
    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
}
```

## 四、成员方法

`LruCache`作为一个二次封装`LinkedHashMap`类，在增删查改上提供非常有限但实用的方法。关键操作都是线程安全的，可放心在多线程中操作同一个`LruCache`实例。

### 4.1 修改容量

可以修改列表最大保存数量，具体请看`trimToSize()`方法的解析

```java
public void resize(int maxSize) {
    if (maxSize <= 0) {
        throw new IllegalArgumentException("maxSize <= 0");
    }

    synchronized (this) {
        this.maxSize = maxSize;
    }
    trimToSize(maxSize);
}
```

### 4.2 添加、获取

通过非空键取值，如果对应键命中就会把值返回，且把这个元素移动到队列首位。没有命中会根据`create()`方法做后续决定。

```java
public final V get(K key) {
    if (key == null) {
        throw new NullPointerException("key == null"); // 禁止使用空键取值
    }

    V mapValue;
    synchronized (this) {
        // 从LinkedHashMap中通过Key获取值
        mapValue = map.get(key);
        if (mapValue != null) {
            hitCount++;      // 命中对应值
            return mapValue; // 返回命中值
        }
        missCount++; // 命中失败
    }

    // 命中失败后尝试构建Value。构建过程可能比较长且当create()返回值时，原队列顺序可能已发生改变。
    // 若发现一个Hash值相同的item已经进入队列，该值会保留下来并抛弃create()的对象
    V createdValue = create(key);
    if (createdValue == null) {
        return null;
    }

    synchronized (this) {
        createCount++;
        // 先用createdValue插入，并获得原位置旧值mapValue
        mapValue = map.put(key, createdValue);

        // 如果mapValue不为空，证明原位置有值
        if (mapValue != null) {
            // 把mapValue又替换回去，刚刚添加进去的createdValue被退出来，相当于原列表没有任何修改
            map.put(key, mapValue);
        } else {
            // 没有冲突，新值成功插入，把新对象的大小加到总大小上
            size += safeSizeOf(key, createdValue);
        }
    }
    
    // 处理两个实例出现冲突后把多余的实例进行垃圾回收，这里是createdValue
    if (mapValue != null) {
        entryRemoved(false, key, createdValue, mapValue);
        return mapValue;
    } else {
        // 创建的新值插入成功，且没有旧的值被替换，trimToSize()检查是否需要裁剪空间
        trimToSize(maxSize);
        return createdValue;
    }
}
```

添加键值逻辑比较简单：已存在的值会被新值取代且移到队列首位，旧值作为方法返回值。

```java
public final V put(K key, V value) {
    if (key == null || value == null) {
        throw new NullPointerException("key == null || value == null");
    }

    V previous;
    synchronized (this) {
        putCount++;
        size += safeSizeOf(key, value);
        previous = map.put(key, value);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        entryRemoved(false, key, previous, value);
    }

    trimToSize(maxSize);
    return previous;
}
```

### 4.3 调整队列容量

已保存元素数量大于新队列容量值，调整过程中选择近期最少使用的item出列。方法实参为`-1`时，所有元素依次移除直到队列为空。

```java
public void trimToSize(int maxSize) {
    while (true) {
        K key;
        V value;
        synchronized (this) {
            if (size < 0 || (map.isEmpty() && size != 0)) {
                throw new IllegalStateException(getClass().getName()
                        + ".sizeOf() is reporting inconsistent results!");
            }

            if (size <= maxSize) {
                break;
            }

            Map.Entry<K, V> toEvict = map.eldest();
            if (toEvict == null) {
                break;
            }

            key = toEvict.getKey();
            value = toEvict.getValue();
            map.remove(key);
            size -= safeSizeOf(key, value);
            evictionCount++;
        }

        entryRemoved(true, key, value, null);
    }
}
```

### 4.4 移除键值

```java
public final V remove(K key) {
    if (key == null) {
        throw new NullPointerException("key == null");
    }

    V previous;
    synchronized (this) {
        previous = map.remove(key);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        entryRemoved(false, key, previous, null);
    }

    return previous;
}
```

### 4.5 值创建和释放

#### 4.5.1 entryRemoved()

entryRemoved目的是被重写。因为有的实例拥有独特的对象回收逻辑，当实例被移出队列时，应该通过此方法完成销毁操作，否则这个被移除的对象按照虚拟机垃圾回收策略进行回收。所以要确定item是否有特殊释放需要，否则忽略释放操作会造成严重内存泄漏问题。

```java
// Called for entries that have been evicted or removed. This method is
// invoked when a value is evicted to make space, removed by a call to
// {@link #remove}, or replaced by a call to {@link #put}. The default
// implementation does nothing.
//
// <p>The method is called without synchronization: other threads may
// access the cache while this method is executing.
//
// @param evicted true if the entry is being removed to make space, false
//     if the removal was caused by a {@link #put} or {@link #remove}.
// @param newValue the new value for {@code key}, if it exists. If non-null,
//     this removal was caused by a {@link #put}. Otherwise it was caused by
//     an eviction or a {@link #remove}.
protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
```

#### 4.5.2 create()

在子类选择性重写此方法，目的是键值命中失败时提供自定义创建功能，把新建item加入队列

```java
// Called after a cache miss to compute a value for the corresponding key.
// Returns the computed value or null if no value can be computed. The
// default implementation returns null.
//
// <p>The method is called without synchronization: other threads may
// access the cache while this method is executing.
//
// <p>If a value for {@code key} exists in the cache when this method
// returns, the created value will be released with {@link #entryRemoved}
// and discarded. This can occur when multiple threads request the same key
// at the same time (causing multiple values to be created), or when one
// thread calls {@link #put} while another is creating a value for the same
// key.
protected V create(K key) {
    return null;
}
```

### 4.6 值大小

私有方法，对`sizeOf()`方法返回结果安全检查

```java
private int safeSizeOf(K key, V value) {
    int result = sizeOf(key, value);
    if (result < 0) {
        throw new IllegalStateException("Negative size: " + key + "=" + value);
    }
    return result;
}
```

假设item中存放的是Bitmap对象，重写sizeof对象实现获取该对象的内存大小。为什么在已预设队列长度的情况下还要重写此方法？

拿图片缓存为例：虽然我们可以控制图片在队列中缓存的数量，但却无法控制所有图片在内存中的占用。可能出现队列保存若干张图，每张图片占用多达16M内存，以至于为数不多的图片占用大量内存。为此，折中的解决方案是计算图片内存占用，即使item依然保存在队列中，当内存占用超过阀值，也要强制释放队列最近未使用资源，被释放的图片以后使用时再考虑重新加载。

元素大小返回默认值为1，表示元素占用一个单位。条目size在运行时不能改变，否则会导致数量控制失效。

```java
protected int sizeOf(K key, V value) {
    return 1;
}
```

### 4.7 清空

调用方法会移除队列保存所有的item。

```java
public final void evictAll() {
    trimToSize(-1);
}
```

### 4.8 Getter
获取队列统计和容量大小的数据

```java
// 方法没有重载，返回缓存元素数量;
// 对于其他类型元素，方法返回所有元素体积总大小.
public synchronized final int size() {
    return size;
}

// 方法没有被重载，返回缓存元素数量最大值;
// 对于其他类型元素，方法返回所有元素体积最大值.
public synchronized final int maxSize() {
    return maxSize;
}

// 元素命中次数
public synchronized final int hitCount() {
    return hitCount;
}

// 元素命中失败次数
public synchronized final int missCount() {
    return missCount;
}

// 新元素被创建次数
public synchronized final int createCount() {
    return createCount;
}

// 元素插入次数
public synchronized final int putCount() {
    return putCount;
}

// 元素丢弃次数
public synchronized final int evictionCount() {
    return evictionCount;
}
```

### 4.9 队列快照

返回队列快照

```java
// Returns a copy of the current contents of the cache, ordered from least
// recently accessed to most recently accessed.
public synchronized final Map<K, V> snapshot() {
    return new LinkedHashMap<K, V>(map);
}
```

