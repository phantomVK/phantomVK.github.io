I"=p<h2 id="一摘要">一、摘要</h2>

<p>HashMap是使用频率高、用于保存键值对映射的容器类。自JDK8始HashMap引入红黑树，调整优化哈希算法，性能相比JDK7有进一步提升。同时，对JDK7中存在多线程操作导致死循环的问题进行修复。本文基于JDK10的源码进行介绍，代码格式进行轻微调整以便阅读。</p>

<p>相关阅读：</p>

<ul>
  <li>
    <p><a href="/2018/07/02/HashTable/">Java源码系列(10) – Hashtable</a></p>
  </li>
  <li>
    <p><a href="/2018/07/09/LinkedHashMap/">Java源码系列(11) – LinkedHashMap</a></p>
  </li>
  <li>
    <p><a href="/2018/07/11/WeakHashMap/">Java源码系列(12) – WeakHashMap</a></p>
  </li>
</ul>

<h2 id="二类签名">二、类签名</h2>

<p>假设键值对能正确分散到不用桶中，那么访问<code class="highlighter-rouge">get()</code>和<code class="highlighter-rouge">put()</code>方法消耗时间近似为一个时间常数。哈希表全遍历性能与哈希桶(table长度)、Node节点(键值对)数量成比例。因此不合适把初始capacity设置太大，或负载因子值load-factor(默认0.75)设置过小。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="nc">Serializable</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>作为通用参数，默认负载因子能很好地平衡<code class="highlighter-rouge">时间开销</code>和<code class="highlighter-rouge">内存开销</code>之间关系。高负载因子值(如&gt;0.75)能减少内存空间开支，但会增加查找的时间开销。如果在构建时正确指定哈希表初始容量，后期可完全避免重哈希操作，换句话说就是令插入操作更高效。</p>

<p><img src="/img/java/HashMap_UML.png" alt="HashMap_UML" /></p>

<p>在类注释里提到几个技术点：</p>

<ul>
  <li>实现Map&lt;K,V&gt;接口；</li>
  <li>HashMap支持空键和空值；</li>
  <li>HashMap线程不安全；</li>
</ul>

<p>与HashMap一并谈论较多的是开发于早期的<a href="/2018/06/30/HashMap/">HashTable</a>，后来被建议使用前者替代，但并不妨碍两者横向比较：</p>

<ul>
  <li>HashTable不支持键或值为null，而HashMap支持；</li>
  <li>HashTable线程安全，与<code class="highlighter-rouge">ConcurrentHashMap</code>一样适用多线程；</li>
  <li>均实现Map&lt;K,V&gt;接口，具有相当的Map操作能力；</li>
  <li>均不保证元素写入与读出顺序的一致性；</li>
</ul>

<p>上文提到，HashMap本身不是线程安全的，可通过以下方式包装实例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nc">Map</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">(...));</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>或把<code class="highlighter-rouge">HashMap</code>替换为<code class="highlighter-rouge">ConcurrentHashMap</code>保证线程安全。</p>

<h2 id="三常量值">三、常量值</h2>

<p>默认初始化大小</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>HashMap容纳元素最大容量</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>默认负载因子</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>从链表转换为红黑树的阈值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>从红黑树退到链表的阈值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>整个哈希表容量超过此值，且链表长度超过TREEIFY_THRESHOLD才树化</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="四数据成员">四、数据成员</h2>

<p>哈希桶表，长度为2的n次幂，不超过MAXIMUM_CAPACITY</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">transient</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>已保存元素数量</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>结构性或元素数量变化总次数</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>下次表扩容阈值，计算自： threshold = capacity * load factor</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>负载因子</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="五节点">五、节点</h2>

<h4 id="51-桶节点">5.1 桶节点</h4>

<p>数据成员<code class="highlighter-rouge">Node&lt;K,V&gt;[] table</code>，实现<code class="highlighter-rouge">Map.Entry&lt;K,V&gt;</code>接口。</p>

<p>节点中的成员变量 <strong>key</strong> ，和 <strong>key</strong> 对应的哈希值 <strong>hash</strong> 均使用 <strong>final</strong> 修饰。因为 <strong>key</strong> 的哈希值 <strong>hash</strong> 决定了该节点在哈希桶的索引，两者是一对一的关系。</p>

<p>假设，节点原始键为 <strong>keyA0</strong> ，经过计算放入了索引为 <strong>0</strong> 的桶。随后，该节点的键修改为 <strong>keyB2</strong>，新哈希值对应桶为 <strong>2</strong>，但实际没有移动节点。那么就会出现，使用 <strong>keyB2</strong> 在桶 <strong>2</strong> 里找不到该节点，使用  <strong>keyA0</strong> 在桶 <strong>0</strong> 里由于键不相同而不能命中。最终，该节点将成为野节点飘在哈希表中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 节点键的哈希值，见小节：5.2 桶索引计算</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>

    <span class="c1">// 节点键</span>
    <span class="kd">final</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>

    <span class="c1">// 节点值</span>
    <span class="no">V</span> <span class="n">value</span><span class="o">;</span>

    <span class="c1">// 下一节点的引用</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span>        <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">()</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>

    <span class="c1">// 这是Entry的哈希值，key和value分别取哈希值再进行异或</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 存入的newValue会替换oldValue，并返oldValue</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="no">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="no">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 同一个对象</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 检查对象o是否为Map.Entry的子类</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;)</span><span class="n">o</span><span class="o">;</span> <span class="c1">// 显式类型转换</span>

            <span class="c1">// 另一个Node的key-value与此Node的对比</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
                <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>哈希冲突解决方法常见有两种：<code class="highlighter-rouge">开放地址法</code>和<code class="highlighter-rouge">拉链法</code>。通过节点字段<code class="highlighter-rouge">Node&lt;K,V&gt; next</code>保存下一个节点的引用，推断出HashMap用拉链法处理哈希冲突问题。</p>

<p><img src="/img/java/HashMap_Node_UML.png" alt="HashMap_Node_UML" /></p>

<h4 id="52-桶索引计算">5.2 桶索引计算</h4>

<p>通常，判断Hash算法是否高效的方式，是看元素是否均匀分放到不同桶中，最好一个桶存放一个元素。即使存放更多元素，也希望每个桶能均匀存放相同数量。如果哈希算法不佳，导致一个桶中存放元素数量特别多，将严重影响存取性能。</p>

<p>为降低碰撞几率，需设置负载因子 loadFactor(默认值0.75)。假设用默认桶数量capacity(初始值16)，通过<code class="highlighter-rouge">threshold = capacity * loadFactor</code>可知当键值对数量超过12时触发扩容。</p>

<p>当然，通过单纯使用大量桶，即便不经优化的哈希算法，也能把元素相对均匀地放在不同桶中，类似通过空间换时间。而JDK的HashMap经过长期验证和修改，已在空间和时间两者取得平衡。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>过往的HashMap在桶数量较少时，连续值经过哈希运算很容易被分配到相同的桶，从而导致哈希碰撞。JDK8把哈希值<code class="highlighter-rouge">高16位</code>与<code class="highlighter-rouge">低16位</code>进行异或运算。在不降低性能的前提下充分利用有限的条件提高混淆度，尽力把元素分配到不用桶。</p>

<p>同时由源码可知<code class="highlighter-rouge">key == null</code>的元素一定会放在第一个哈希桶中。</p>

<p>下图展示hashCode高低位运算：</p>

<p><img src="/img/java/HashMap_bit_hashCode.png" alt="HashMap_bit_hashCode" /></p>

<p>这种运算方式有以下好处：</p>

<ul>
  <li>满足速度、功效、位分散质量等条件；</li>
  <li>避免使用%操作的同时，令位运算发挥更好效果；</li>
  <li>避免性能损耗，开销较低</li>
</ul>

<h4 id="53-计算哈希表大小">5.3 计算哈希表大小</h4>

<p>通过给定值计算得<code class="highlighter-rouge">相等或更大</code>且<code class="highlighter-rouge">大小为2^n</code>的数值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>下面假设cap为15，通过<code class="highlighter-rouge">tableSizeFor()</code>计算：</p>

<p><img src="/img/java/HashMap_tableSizeFor.png" alt="HashMap_tableSizeFor" /></p>

<p>当流程进行到<code class="highlighter-rouge">n|=n&gt;&gt;&gt;4</code>，后续步骤运算结果已经固定不变。参数cap为15计算得到最终结果为16。</p>

<h2 id="六成员方法">六、成员方法</h2>

<h4 id="61-构造方法">6.1 构造方法</h4>

<p>指定初始容量值和负载因子值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal initial capacity: "</span> <span class="o">+</span>
                                           <span class="n">initialCapacity</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal load factor: "</span> <span class="o">+</span>
                                           <span class="n">loadFactor</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>指定初始容量值，并使用默认负载因子值0.75。注意，初始容量值只能为非负数</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>构造空HashMap，默认初始容量为16，默认负载因子为0.75。其他参数使用默认值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>通过给定Map创建新的HashMap。负载因子默认为0.75，容量值为足够保存m中键值对的大小。若m为null抛出NullPointerException</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="62-查询">6.2 查询</h4>

<p>根据键和哈希值查找对应键值对</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">getNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// tab: 哈希表</span>
    <span class="c1">// first: 桶内首节点</span>
    <span class="c1">// n: 哈希桶索引</span>
    <span class="c1">// k: 临时Node变量</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span>
        <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 检查桶内首节点是否匹配</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="k">return</span> <span class="n">first</span><span class="o">;</span>

        <span class="c1">// 查找桶内其他节点</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 桶内节点以红黑树的方式保存，用红黑树的方法查找节点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                <span class="k">return</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            
            <span class="c1">// 桶内节点以链表的方式保存，遍历链表查找节点</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 哈希表没有元素，或没有找到对应Node</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>返回key对应的value，若key没有对应映射则返回null</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>查询是否包含该键对应的值</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="63-插入">6.3 插入</h4>

<p><strong>onlyIfAbsent</strong> 为true时新值不会替换已存在的旧值，<strong>evict</strong> 为false时哈希表正处于创建模式。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span>
               <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span>
               <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// tab: 局部变量哈希表，即HashMap.table[];</span>
    <span class="c1">// n: 哈希表长度，即tab[].length;</span>
    <span class="c1">// i: 哈希桶索引，即(n - 1) &amp; hash;</span>
    <span class="c1">// p: 哈希桶首Node，即tab[i]</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>

    <span class="c1">// table == null 或 table.length == 0，构建新哈希表</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// resize()里新哈希表会在方法内赋值给table</span>
        <span class="c1">// 后返回哈希表引用并赋值给tab</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 通过hash值确定哈希桶</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// table[index]为null，创建新Node并放入数组该位置</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// table[index]不为null，表示桶内已有至少一个Node</span>
        <span class="c1">// e: 临时保存节点</span>
        <span class="c1">// k: 桶首节点键</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
            <span class="c1">// 确定节点p.key哈希与插入节点k.key哈希是否相同</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 桶首节点继承自TreeNode，调用红黑树的putTreeVal()</span>
            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 把节点插入到哈希桶链表队尾，FIFO。JDK7或之前版本是头插法</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 创建新节点，尾插法保存到链表尾</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>

                    <span class="c1">// 桶内节点数超过TREEIFY_THRESHOLD，需要转为红黑树，并退出迭代</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 找到key完全相同的节点，直接替换此节点的value</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 相同key已有oldValue存在</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            
            <span class="c1">// onlyIfAbsent为true，当存在oldValue映射到key就不用newValue替换</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>

            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            
            <span class="c1">// 返回已存在value，若value不存在则返回值为null</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 增加修改次数</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>

    <span class="c1">// 已保存元素数量超过阈值扩容哈希表</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>

    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>存入键值对，若此前已存在一个键值对，会返回上一个值，否则返回null</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="64-批量插入">6.4 批量插入</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">void</span> <span class="nf">putMapEntries</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// m为null则抛出NullPointerException</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">table</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果本HashMap为null，用m的大小决定本HashMap的初始大小</span>
            <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">((</span><span class="kt">float</span><span class="o">)</span><span class="n">s</span> <span class="o">/</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="no">F</span><span class="o">;</span>

            <span class="c1">// 检查是否超过大小限制</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
                     <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">);</span>

            <span class="c1">// 向上规整</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// HashMap不为null，扩容一倍</span>
            <span class="n">resize</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="c1">// 依次遍历m的节点，存入本HashMap</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="no">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="c1">// onlyIfAbsent为false</span>
            <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">evict</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>调用方法 <strong>putMapEntries()</strong>，<strong>evict</strong> 参数为 <strong>true</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">putAll</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="65-扩容">6.5 扩容</h4>

<p>通过此方法扩大哈希表容量，每次扩容都会增大table长度，已有节点需重哈希放入新哈希桶内。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 旧哈希表</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    
    <span class="c1">// 旧哈希表长度</span>
    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    
    <span class="c1">// 旧表扩容阈值</span>
    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
    
    <span class="c1">// 新容量，下一个阈值</span>
    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 超过数量上限则不再扩容</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                 <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 扩充为原来两倍: 左移原值乘以2，右移原值除以2</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 哈希表没有创建，但是已设定扩容阈值，则用该阈值去初始化</span>
        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// aka: oldCap == 0 &amp;&amp; oldThr == 0</span>
        <span class="c1">// 哈希表既没有初始化，也没有设置初始阈值，则通过默认值进行初始化</span>
        <span class="n">newCap</span> <span class="o">=</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
    <span class="o">}</span>
   
    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="no">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                  <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
    
    <span class="c1">// 创建新哈希表</span>
    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">"rawtypes"</span><span class="o">,</span><span class="s">"unchecked"</span><span class="o">})</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
    
    <span class="c1">// 旧表元素重哈希到新表</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 依次处理旧哈希表的哈希桶</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 把链表或红黑树从旧表解链接</span>
                
                <span class="c1">// 桶内只有一个元素</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 在新哈希表中给元素e选桶</span>
                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 把红黑树的元素放到新表</span>
                    <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// 桶内有多个元素且结构为链表，使用以下优化算法:</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
                    <span class="k">do</span> <span class="o">{</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// 低位新哈希桶首个元素，e赋值给loHead</span>
                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="c1">// 低位新哈希桶后续元素，接到loTail的下一个位置</span>
                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span>

                            <span class="c1">// 调整loTail引用</span>
                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// 高位新哈希桶首个元素，e赋值给hiHead</span>
                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="c1">// 高位新哈希桶后续元素，接到hiTail的下一个位置</span>
                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span>
                            <span class="o">}</span>

                            <span class="c1">// 调整hiTail引用</span>
                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>

                    <span class="c1">// 链表存入低位哈希桶</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// 链表存入高位哈希桶</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span> <span class="c1">// 扩容完毕，返回新哈希表</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>下面举例一个旧表：</p>
<ul>
  <li>第一行是数值<code class="highlighter-rouge">oldCap</code>，这个例子是4；</li>
  <li>第二行是每个数值的<code class="highlighter-rouge">e.hash</code>；</li>
  <li>第三行是位运算<code class="highlighter-rouge">(e.hash &amp; oldCap) == 0</code>得出红色数字；</li>
</ul>

<p><img src="/img/java/HashMap_oldMap.png" alt="HashMap_oldMap" /></p>

<p>扩容后的新表，对比旧表中的数字：</p>

<ul>
  <li>位运算为<code class="highlighter-rouge">0</code>的放在原桶索引位置<code class="highlighter-rouge">oldIndex</code></li>
  <li>位运算为<code class="highlighter-rouge">1</code>的放在新桶索引位置<code class="highlighter-rouge">oldIndex+oldCap</code>
<img src="/img/java/HashMap_newMap.png" alt="HashMap_newMap" /></li>
</ul>

<p>于是从运算前旧表<code class="highlighter-rouge">oldCap</code>为4换新表<code class="highlighter-rouge">newCap</code>为8，且元素全部经过重哈希放入新桶中：</p>

<p><img src="/img/java/HashMap_resize.png" alt="HashMap_resize" /></p>

<h4 id="66-树化节点">6.6 树化节点</h4>

<p>把链表转换为红黑树：首先把链表的节点更换为红黑树节点，然后把整条链变形为红黑树</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeifyBin</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>

    <span class="c1">// 链表长度不超过MIN_TREEIFY_CAPACITY则仅进行扩容，不转换为红黑树</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MIN_TREEIFY_CAPACITY</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 头节点hd，尾节点tl</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="c1">// 更换链表节点为红黑节点链表</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">replacementTreeNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tl</span><span class="o">;</span>
                <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
        
        <span class="c1">// 头节点非空，转换红黑节点链表为红黑树</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">hd</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">hd</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="67-删除">6.7 删除</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span>
                           <span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span>
                           <span class="kt">boolean</span> <span class="n">matchValue</span><span class="o">,</span>
                           <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span>

    <span class="c1">// 哈希表不为null，且桶首节点不为null</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span>
        <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span> <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        
        <span class="c1">// 匹配桶首节点</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 遍历红黑树</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">node</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 遍历链表</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                         <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 遍历节点不为空，表示找到目标节点</span>
        <span class="c1">// 若matchValue为true，则需同时匹配key-value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">matchValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                             <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 节点为红黑树，通过红黑树的方式移除节点</span>
                <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">node</span><span class="o">).</span><span class="na">removeTreeNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">movable</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 匹配为链表的桶首节点，直接把链表第二个节点替换其位置</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 非链表头结点元素，相当于把node解除链接</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span> <span class="c1">// 哈希表修改次数加一</span>
            <span class="o">--</span><span class="n">size</span><span class="o">;</span> <span class="c1">// 移除一个元素</span>

            <span class="n">afterNodeRemoval</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>matchValue</strong> 为 <strong>false</strong>，<strong>movable</strong> 为 <strong>true</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="no">V</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
        <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="68-清空">6.8 清空</h4>

<p>把桶首节点元素与哈希表解链接，桶内的链表或红黑树由虚拟机回收</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
    <span class="n">modCount</span><span class="o">++;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 已保存元素数量复位</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 链表或红黑树与哈希表解除连接</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="69-包含">6.9 包含</h4>

<p>如果是红黑树，则调用 <strong><a href="/2018/06/30/HashMap/#74-查找节点">find(int h, Object k, Class&lt;?&gt; kc)</a></strong>，本方法仅为链表所用。</p>

<p>查找 <strong>value</strong> 不像 <strong>key</strong>：</p>

<ul>
  <li><strong>key</strong> 能先算出其hash值并跳到对应桶进行查找；</li>
  <li>而 <strong>value</strong> 只能遍历整张表所有元素逐一对比；</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsValue</span><span class="o">(</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 依次遍历每个哈希桶</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">tab</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 遍历哈希桶内所有节点</span>
            <span class="k">for</span> <span class="o">(;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 查找是否存在保存了该value的节点e</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">)))</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 哈希表为空，或没有找到匹配键值对</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="610-计算容量">6.10 计算容量</h4>

<ul>
  <li>哈希表不为空，返回哈希表长度；</li>
  <li>哈希表为空但<code class="highlighter-rouge">threshold</code>大于0，返回<code class="highlighter-rouge">threshold</code>；</li>
  <li>否则返回默认初始化大小16</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">int</span> <span class="nf">capacity</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">table</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span> <span class="o">:</span>
        <span class="o">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">threshold</span> <span class="o">:</span>
        <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="七红黑树节点">七、红黑树节点</h2>

<p><code class="highlighter-rouge">TreeNode</code>是<code class="highlighter-rouge">HashMap</code>的静态内部类</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">TreeNode</code>的UML：
<img src="/img/java/HashMap_TreeNode_UML.png" alt="HashMap_TreeNode_UML" /></p>

<h4 id="71-数据成员与构造方法">7.1 数据成员与构造方法</h4>

<p>数据成员</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span>  <span class="c1">// 父节点</span>
<span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span> <span class="c1">// 左子树</span>
<span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span> <span class="c1">// 右子树</span>
<span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>    <span class="c1">// needed to unlink next upon deletion</span>
<span class="kt">boolean</span> <span class="n">red</span><span class="o">;</span> <span class="c1">// 节点颜色: 红色或黑色</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>构造方法</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nc">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">val</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="72-获取根节点">7.2 获取根节点</h4>

<p>沿着<code class="highlighter-rouge">TreeNode.parent</code>遍历到根节点</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">p</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="73-移动根节点">7.3 移动根节点</h4>

<p>保证树的根节点一定是哈希桶的第一个元素</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">moveRootToFront</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>

    <span class="c1">// 根节点非空、哈希表不为空、桶首节点不为空</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根据哈希值查哈希桶</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
        <span class="c1">// 获取桶首元素</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        
        <span class="c1">// 桶首元素不是红黑树的根节点，则开始移动节点</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// eq. root.next </span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">rn</span><span class="o">;</span>
            <span class="c1">// 根节点赋值到桶首元素</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            <span class="c1">// 根节点的前一个节点</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>

            <span class="c1">// root.next不为空，把root.prev赋值给root.next.prev，相当于把root节点解除链接</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">rn</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">rn</span><span class="o">).</span><span class="na">prev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">;</span>
            
            <span class="c1">// root.prev不为空，则root.prev.next = root.next，相当于把root节点解除链接</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">rp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">rn</span><span class="o">;</span>
            
            <span class="c1">// 桶首节点不为空，把根节点作为桶首节点的上一个节点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">first</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
            
            <span class="c1">// 原桶首节点现在作为root的下一个节点</span>
            <span class="n">root</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
            <span class="c1">// 首节点没有prev</span>
            <span class="n">root</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 检查处理后的红黑树树是否符合标准</span>
        <span class="k">assert</span> <span class="nf">checkInvariants</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="74-查找节点">7.4 查找节点</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ph</span><span class="o">,</span> <span class="n">dir</span><span class="o">;</span> <span class="no">K</span> <span class="n">pk</span><span class="o">;</span>
        <span class="c1">// 左叶子pl，有叶子pr</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">q</span><span class="o">;</span>
        
        <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 节点的哈希值大于需查找的哈希值h，h和左叶子比较</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 节点的哈希值小于需查找的哈希值h，h和右叶子比较</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">pk</span><span class="o">)))</span> <span class="o">{</span>
            <span class="c1">// hash值相同，且value也相同，当前节点就是要查找的节点，返回</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 左叶子为空，则切换到右叶子</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 右叶子为空，则切换到左叶子</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span>
                  <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                 <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// p.hash == h &amp;&amp; p.key != k &amp;&amp; pl != null &amp;&amp; pr != null</span>
            <span class="c1">// 通过compareComparables比较pk和k大小，dir小于0，走左子树，否则走右子树</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">pl</span> <span class="o">:</span> <span class="n">pr</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 进入右叶子递归查找</span>
            <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 切换到左叶子，进入左叶子递归查找</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    
    <span class="c1">// 整棵树查找结束，没有找到目标节点，返回null</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">getTreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">root</span><span class="o">()</span> <span class="o">:</span> <span class="k">this</span><span class="o">).</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="75-大小比较">7.5 大小比较</h4>

<p>节点的键没有实现<code class="highlighter-rouge">Comparable</code>接口，或键通过<code class="highlighter-rouge">compareTo</code>比较相同时，需要通过此方法比较大小</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span> <span class="nf">tieBreakOrder</span><span class="o">(</span><span class="nc">Object</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">d</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
         <span class="c1">// 通过类名进行compareTo比较，不同则用此结果</span>
        <span class="c1">// a为null，或b为null，或两个对象类名对比相同，就用hashCode值比较，小于等于返回-1，否则返回1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">?</span>
             <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="76-构建红黑树">7.6 构建红黑树</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeify</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 根节点</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 正在遍历节点的下一个节点</span>
        <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">// 置空左右节点</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="c1">// 根节点为空，把当前节点作为根节点，且节点颜色为黑色</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 已存在根节点</span>
            <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>    <span class="c1">// 当前节点的key</span>
            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span> <span class="c1">// 当前节点的value</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// key的类型，KeyClass</span>

            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;;)</span> <span class="o">{</span> <span class="c1">// 从根节点开始遍历</span>
                <span class="kt">int</span> <span class="n">dir</span><span class="o">,</span> <span class="n">ph</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                
                <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span> <span class="c1">// p.hash大于节点x.hash，放在节点p左侧</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span> <span class="c1">// p.hash小于节点x.hash，放在节点p右侧</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                          <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                         <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="c1">// 先通过compareComparables比较，当dir == 0，</span>
                    <span class="c1">// 还需要进行下面多一轮比较决定放在左子树还是右子树</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="n">tieBreakOrder</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">);</span>
                    <span class="c1">// 到这里dir只可能是1或-1</span>

                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// xp意为：xParent</span>

                <span class="c1">// 如果左子树或右子树为空，就地插入，否则进入下一次for循环查找</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                    
                    <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>  <span class="c1">// 放在父节点左子树</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// 放在父节点右子树</span>
                    <span class="o">}</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">balanceInsertion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 把红黑树根节点放在哈希桶首位</span>
    <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="77-去树化">7.7 去树化</h4>

<p>把红黑树转换为链表形式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">untreeify</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 链表头指针hd，链表尾指针tl</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 把红黑树节点更换为普通链表节点</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">replacementNode</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 然后把所有节点按照遍历的顺序依次串起来</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">hd</span><span class="o">;</span> <span class="c1">// 返回一条链表</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="78-插入树节点">7.8 插入树节点</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre><span class="c1">// @param map HashMap</span>
<span class="c1">// @param tab 哈希桶</span>
<span class="c1">// @param h 元素哈希值</span>
<span class="c1">// @param k 元素key</span>
<span class="c1">// @param v 元素value</span>
<span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">putTreeVal</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span>
                               <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">searched</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="c1">// 查找根节点</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">root</span><span class="o">()</span> <span class="o">:</span> <span class="k">this</span><span class="o">;</span>
    
    <span class="c1">// 从根节点开始遍历，p为当前节点，&lt;k,v&gt;为对比节点</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">dir</span><span class="o">,</span> <span class="n">ph</span><span class="o">;</span> <span class="no">K</span> <span class="n">pk</span><span class="o">;</span>
        
        <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span>
            <span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 对比元素比当前节点的哈希值大，进入左子树比较</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span>
            <span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 进入右子树比较</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">pk</span><span class="o">)))</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 当前节点的key和value都和元素相同，即当前节点就是需要找的节点</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                  <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                 <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">searched</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">ch</span><span class="o">;</span>
                <span class="n">searched</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="c1">// 分别从左子树和右子树找</span>
                <span class="k">if</span> <span class="o">(((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                     <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                     <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span>
                    <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 没有遍历到和哈希值h相同的节点</span>
            <span class="n">dir</span> <span class="o">=</span> <span class="n">tieBreakOrder</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">xpn</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            
            <span class="c1">// 创建新节点</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">newTreeNode</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">xpn</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// 作为左子树</span>
            <span class="k">else</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// 作为右子树</span>
            <span class="n">xp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">xpn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">xpn</span><span class="o">).</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="c1">// 插入平衡，并调整根节点到树顶</span>
            <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">balanceInsertion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span><span class="o">));</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="79-移除树节点">7.9 移除树节点</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">void</span> <span class="nf">removeTreeNode</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span>
                          <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">;</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">first</span><span class="o">,</span> <span class="n">rl</span><span class="o">;</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">next</span><span class="o">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">succ</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">root</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span>
        <span class="o">||</span> <span class="o">(</span><span class="n">movable</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span>
                <span class="o">||</span> <span class="o">(</span><span class="n">rl</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span>
                <span class="o">||</span> <span class="n">rl</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)))</span> <span class="o">{</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>  <span class="c1">// 退化</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">right</span><span class="o">,</span> <span class="n">replacement</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pr</span><span class="o">,</span> <span class="n">sl</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 查找继承节点</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">sl</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">red</span><span class="o">;</span> <span class="n">s</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">red</span><span class="o">;</span> <span class="n">p</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// 交换颜色</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">pr</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// p was s's direct parent</span>
            <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
            <span class="n">s</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">sp</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                    <span class="n">sp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">sp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">pr</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">pr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">sr</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">sr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">pl</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">pl</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">pp</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">replacement</span> <span class="o">=</span> <span class="n">sr</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">replacement</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">replacement</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">red</span> <span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">balanceDeletion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">replacement</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">replacement</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// detach</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">movable</span><span class="o">)</span>
        <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="710-分割">7.10 分割</h4>

<p>把红黑树分割为高位桶和低位桶，如果分割后桶内元素数量较少，桶内哈希表会退化为链表。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre><span class="c1">// @param map 哈希表</span>
<span class="c1">// @param tab 哈希桶</span>
<span class="c1">// @param index 别分割的桶索引</span>
<span class="c1">// @param bit   用于分割的哈希值的位</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">split</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="c1">// 重链接到高位列表或低位列表，且保持基本顺序</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">lc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="c1">// 元素放在低位桶上</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">loTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="c1">// 元素按照链表的方式放置</span>
            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">++</span><span class="n">lc</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span> <span class="c1">// 元素放在高位桶上</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">hiTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="c1">// 元素按照链表的方式放置</span>
            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">++</span><span class="n">hc</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">loHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lc</span> <span class="o">&lt;=</span> <span class="no">UNTREEIFY_THRESHOLD</span><span class="o">)</span> <span class="c1">// 低位桶元素数量少于UNTREEIFY_THRESHOLD</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span> <span class="c1">// 桶内元素减少，去树化</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hiHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">loHead</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hiHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hc</span> <span class="o">&lt;=</span> <span class="no">UNTREEIFY_THRESHOLD</span><span class="o">)</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">bit</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span> <span class="c1">// 桶内元素减少，去树化</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">bit</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">loHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">hiHead</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="711-翻转左子树">7.11 翻转左子树</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                      <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// r = p.right</span>
    <span class="c1">// pp = p.parent</span>
    <span class="c1">// rl = p.right.left</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">,</span> <span class="n">pp</span><span class="o">,</span> <span class="n">rl</span><span class="o">;</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 左旋节点的右子树不为空</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">rl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>  <span class="c1">// 把p.right.left = p.right</span>
            <span class="n">rl</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// p.right.left.parent = p</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="o">(</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span><span class="o">).</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 根节点颜色为黑</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="n">r</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="712-翻转右子树">7.12 翻转右子树</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                       <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// l = p.left</span>
    <span class="c1">// pp = p.parent</span>
    <span class="c1">// lr = p.left.right</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">,</span> <span class="n">pp</span><span class="o">,</span> <span class="n">lr</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 右旋节点的左子树不为空</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">lr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 把p.left.right = p.left</span>
            <span class="n">lr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// p.left.right.parent = p</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="o">(</span><span class="n">root</span> <span class="o">=</span> <span class="n">l</span><span class="o">).</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 根节点颜色为黑</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
        <span class="n">l</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="713-平衡插入">7.13 平衡插入</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">balanceInsertion</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 新插入节点为红节点</span>
    <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    
    <span class="c1">// xp： 当前节点的父节点</span>
    <span class="c1">// xpp： 当前节点的爷爷节点</span>
    <span class="c1">// xppl：当前节点的左叔节点</span>
    <span class="c1">// xppr：当前节点的右叔节点</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span><span class="o">,</span> <span class="n">xpp</span><span class="o">,</span> <span class="n">xppl</span><span class="o">,</span> <span class="n">xppr</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="c1">// 节点为根节点，更根据红黑树条件来说，根节点一定为黑色</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">||</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="o">(</span><span class="n">xppl</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 父节点是爷爷节点的左子树</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">xppr</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xppr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 右叔叔节点非空，且为红色</span>
                <span class="n">xppr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 右叔叔为黑色</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>   <span class="c1">// 父节点为给色</span>
                <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>   <span class="c1">// 爷爷节点的红色</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">;</span> <span class="c1">// 爷爷作为下轮处理的节点</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 该节点为父节点的右节点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 当前节点是父节点的右子树</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">);</span>
                    <span class="n">xpp</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span> <span class="c1">// 获取爷爷节点</span>
                <span class="o">}</span>
                
                <span class="c1">// 父节点不为空</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 父节点为黑色</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 爷爷节点为红色节点</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpp</span><span class="o">);</span> <span class="c1">// 爷爷节点右旋</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">xppl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xppl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 左叔节点非空且为红色</span>
                <span class="n">xppl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 左叔节点为红色</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 父节点为黑色</span>
                <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 爷爷为红色</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span> <span class="c1">// 左叔节点为空，或为黑色</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 当前节点为做孩子</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">);</span>
                    <span class="n">xpp</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 黑色父节点</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 爷爷节点为红色</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpp</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="714-平衡删除">7.14 平衡删除</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">balanceDeletion</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                           <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span><span class="o">,</span> <span class="n">xpl</span><span class="o">,</span> <span class="n">xpr</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">root</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">xpl</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">xpr</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xpr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                <span class="n">xpr</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">xpr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">sl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                            <span class="n">sl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpr</span><span class="o">);</span>
                        <span class="n">xpr</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
                            <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">sr</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                            <span class="n">sr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span> <span class="c1">// 对称</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xpl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                <span class="n">xpl</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                            <span class="n">sr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpl</span><span class="o">);</span>
                        <span class="n">xpl</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
                            <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">sl</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                            <span class="n">sl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="715-递归检查">7.15 递归检查</h4>

<p>检查操作完成的红黑树是否合法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">checkInvariants</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">parent</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">,</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">,</span> <span class="n">tn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tb</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tn</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tn</span><span class="o">.</span><span class="na">prev</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tp</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">.</span><span class="na">left</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tl</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">||</span> <span class="n">tl</span><span class="o">.</span><span class="na">hash</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">hash</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tr</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">||</span> <span class="n">tr</span><span class="o">.</span><span class="na">hash</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">hash</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">red</span> <span class="o">&amp;&amp;</span> <span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tl</span><span class="o">.</span><span class="na">red</span> <span class="o">&amp;&amp;</span> <span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInvariants</span><span class="o">(</span><span class="n">tl</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInvariants</span><span class="o">(</span><span class="n">tr</span><span class="o">))</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="八参考链接">八、参考链接</h2>

<ul>
  <li><a href="https://tech.meituan.com/java-hashmap.html">美团技术团队 -  Java 8系列之重新认识HashMap</a></li>
  <li><a href="http://www.hchstudio.cn/article/2018/10fc/">I-team - 死磕Java之聊聊HashMap源码(基于JDK1.8)</a></li>
  <li><a href="https://stackoverflow.com/a/6405709/8750399">StackOverflow - Does HashTable maintains the insertion order?</a></li>
  <li><a href="https://stackoverflow.com/a/11981897/8750399">StackOverflow - Why Hashtable does not allow null keys or values?</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/34361643">知乎 - JoonWhee - HashMap讲解(上)</a></li>
  <li><a href="https://blog.csdn.net/chenssy/article/details/73749297">CSDN - chenssy - 【死磕Java并发】—–J.U.C之ConcurrentHashMap红黑树转换分析</a></li>
</ul>
:ET