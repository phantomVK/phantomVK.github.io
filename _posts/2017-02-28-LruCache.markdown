---
layout:     post
title:      "Android源码系列(6) -- LruCache"
date:       2017-02-28
author:     "phantomVK"
header-img: "img/main_img.jpg"
catalog:    true
tags:
    - Android源码系列
---


## 一、类签名

LruCache是Android提供的缓存工具类，根据最近最少使用算法缓存元素，避免缓存过多导致内存占用过大，或内存释放不及时引起内存溢出。

```java
public class LruCache<K, V>
```

资源缓存除了最近最少使用外，还巧妙利用Java对象引用类型完成内存回收。这4种类型分别是强、软、弱、虚。

被操作的元素会移到队列末位。一段时间后本来处于队列末位的元素，因为其他元素的操作逐渐前进到队头。如果队列空间足够，所有元素都不会移除。否则处于队头的元素优先移除，腾出空间容纳新元素。所以使用热度高的资源得到有效缓存，长时间没有使用的资源会被移出队列。这些操作均依赖[LinkedHashMap](https://phantomvk.github.io/2018/07/09/LinkedHashMap/)

为了使该类适合实际应用，开发中多继承`LruCache`，重写`create()`、`entryRemoved()`和`sizeOf()`等方法。

## 二、数据成员


`LruCache`通过`LinkedHashMap`数据结构来完成item的保存

```java
private final LinkedHashMap<K, V> map;
```

两个数值分别用来记录`保存容量`及`最大容量`，且前者不大于后者。值得注意的是，这个容量可能是键的个数(针对Key)，也可能是值总体积(针对Value)。例如通过LruCache缓存图片，既可以通过限制图片数量，也可以限制缓存图片容量总大小实现内存管理。

```java
private int size;
private int maxSize;
```

用来保存各种操作统计次数，如：添加一个元素`putCount`递增一次。

```java
private int putCount;     // 加入
private int createCount;  // 创建
private int evictionCount;// 舍弃
private int hitCount;     // 查找命中
private int missCount;    // 命中失败
```

## 三、构造方法

`maxSize`记录整个列表最大保存数。为避免严重的哈希冲突，`LinkedHashMap`哈希因子设定为0.75。

`LinkedHashMap`构造函数参数`accessOrder`为`true`时以访问顺序排列元素，否则以插入顺序排列元素。从源码可知`LruCache`使用`LinkedHashMap`时`accessOrder`为`true`。

```java
public LruCache(int maxSize) {
    if (maxSize <= 0) {
        throw new IllegalArgumentException("maxSize <= 0");
    }
    this.maxSize = maxSize;
    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
}
```

## 四、成员方法

`LruCache`作为一个二次封装`LinkedHashMap`类，在增删查改上提供非常有限但实用的方法。关键操作都是线程安全的，可放心在多线程中操作同一个`LruCache`实例。

### 4.1 设置大小

可以修改列表最大保存数量，具体请看`trimToSize()`方法的解析

```java
public void resize(int maxSize) {
    if (maxSize <= 0) {
        throw new IllegalArgumentException("maxSize <= 0");
    }

    synchronized (this) {
        this.maxSize = maxSize;
    }
    trimToSize(maxSize);
}
```

### 4.2 添加、获取

通过非空键取值，如果对应键命中就会把值返回，且把这个元素移动到队列首位。没有命中会根据`create()`方法做后续决定。

```java
public final V get(K key) {
    if (key == null) {
        throw new NullPointerException("key == null"); // 禁止使用空键取值
    }

    V mapValue;
    synchronized (this) {
        // 从LinkedHashMap中通过Key获取值
        mapValue = map.get(key);
        if (mapValue != null) {
            hitCount++;      // 命中对应值
            return mapValue; // 返回命中值
        }
        missCount++; // 命中失败
    }

    // 命中失败后尝试构建Value
    // 构建过程可能比较长且当create()返回值时，原队列顺序可能已发生改变。
    // 若发现一个Hash值相同的item已经进入队列，该值会保留下来并抛弃create()的对象
    V createdValue = create(key);
    if (createdValue == null) {
        return null;
    }

    synchronized (this) {
        createCount++;
        // 先用createdValue插入，并获得原位置旧值mapValue
        mapValue = map.put(key, createdValue);

        // 如果mapValue不为空，证明原位置有值
        if (mapValue != null) {
            // 把mapValue又替换回去，刚刚添加进去的createdValue被换出来，相当于没有任何修改
            map.put(key, mapValue);
        } else {
            // 没有冲突，新值成功插入，把新对象的大小加到总大小上
            size += safeSizeOf(key, createdValue);
        }
    }
    
    // 处理两个实例出现冲突后把多余的实例进行垃圾回收，这里是createdValue
    if (mapValue != null) {
        entryRemoved(false, key, createdValue, mapValue);
        return mapValue;
    } else {
        // 创建的新值插入成功，且没有旧的值被替换，trimToSize()检查是否需要调整空间
        trimToSize(maxSize);
        return createdValue;
    }
}
```

添加键值逻辑比较简单：已存在的值会被新值取代且移到队列首位，旧值作为方法返回值。

```java
public final V put(K key, V value) {
    if (key == null || value == null) {
        throw new NullPointerException("key == null || value == null");
    }

    V previous;
    synchronized (this) {
        putCount++;
        // 添加新元素，把新元素的大小增加到size
        size += safeSizeOf(key, value);
        // 被替换出来的元素
        previous = map.put(key, value);
        // 减去上一个元素空间占用
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        // 执行移除操作
        entryRemoved(false, key, previous, value);
    }

    // 调整大小
    trimToSize(maxSize);
    return previous;
}
```

### 4.3 调整容量

已保存元素数量大于新队列容量值，调整过程中选择近期最少使用的item出列。若`maxSize`值为`-1`，所有元素依次移除直至队列为空。

```java
public void trimToSize(int maxSize) {
    while (true) {
        K key;
        V value;
        synchronized (this) {
            if (size < 0 || (map.isEmpty() && size != 0)) {
                throw new IllegalStateException(getClass().getName()
                        + ".sizeOf() is reporting inconsistent results!");
            }

            if (size <= maxSize) {
                break;
            }
            
            // 获取最近最少使用的元素
            Map.Entry<K, V> toEvict = map.eldest();
            if (toEvict == null) {
                break;
            }

            key = toEvict.getKey();
            value = toEvict.getValue();
            // 从LinkedHashMap中移除
            map.remove(key);
            // 调整总大小
            size -= safeSizeOf(key, value);
            evictionCount++;
        }

        entryRemoved(true, key, value, null);
    }
}
```

### 4.4 移除键值

```java
public final V remove(K key) {
    if (key == null) {
        throw new NullPointerException("key == null");
    }

    V previous;
    synchronized (this) {
        // 根据key在LinkedHashMap中查找元素
        previous = map.remove(key);
        // 元素成功移除，减去元素大小
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        entryRemoved(false, key, previous, null);
    }

    return previous;
}
```

### 4.5 值创建和释放

#### 4.5.1 entryRemoved()

有的实例拥有独特的对象回收逻辑，当实例被移出队列时，应该通过此方法完成销毁操作，否则这个被移除的对象仅按照虚拟机垃圾回收策略进行回收。所以要确定item是否有特殊释放需要，忽略释放操作会造成严重内存泄漏问题。

```java
protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
```

#### 4.5.2 create()

在子类选择性重写此方法，目的是键值命中失败时把新建item加入队列，默认返回null。

```java
protected V create(K key) {
    return null;
}
```

### 4.6 值大小

私有方法，对`sizeOf()`方法返回结果安全检查。假设item中存放的是Bitmap对象，需重写sizeof对象实现获取该对象的内存大小。

```java
private int safeSizeOf(K key, V value) {
    int result = sizeOf(key, value);
    if (result < 0) {
        throw new IllegalStateException("Negative size: " + key + "=" + value);
    }
    return result;
}
```

拿图片缓存为例：虽然可以控制图片在队列中缓存的数量，但却无法控制图片在内存中的占用。可能出现队列保存若干张图，每张图片占用多达16M内存，以至于为数不多的图片占用大量内存。为此，折中的解决方案是计算图片内存占用，即使item依然保存在队列中，当内存占用超过阈值，也要强制释放队列最近最少使用资源，被释放图片以后使用时再重新加载。

```java
protected int sizeOf(K key, V value) {
    return 1;
}
```

默认值为1，表示元素占用一个单位。条目size在运行时不能改变，否则会导致数量控制失效。

### 4.7 清空

调用方法会移除队列保存所有的item。

```java
public final void evictAll() {
    trimToSize(-1);
}
```

### 4.8 Getter
获取队列统计和容量大小的数据

```java
// 方法没有重载，返回缓存元素数量;
// 对于其他类型元素，方法返回所有元素体积总大小.
public synchronized final int size() {
    return size;
}

// 方法没有被重载，返回缓存元素数量最大值;
// 对于其他类型元素，方法返回所有元素体积最大值.
public synchronized final int maxSize() {
    return maxSize;
}

// 元素命中次数
public synchronized final int hitCount() {
    return hitCount;
}

// 元素命中失败次数
public synchronized final int missCount() {
    return missCount;
}

// 新元素被创建次数
public synchronized final int createCount() {
    return createCount;
}

// 元素插入次数
public synchronized final int putCount() {
    return putCount;
}

// 元素丢弃次数
public synchronized final int evictionCount() {
    return evictionCount;
}
```

### 4.9 队列快照

返回队列快照的浅拷贝，且保留所有元素最近访问的顺序。

```java
public synchronized final Map<K, V> snapshot() {
    return new LinkedHashMap<K, V>(map);
}
```

