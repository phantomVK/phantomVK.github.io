---
layout:     post
title:      "即时通讯头像理论"
date:       2019-05-19
author:     "phantomVK"
header-img: "img/bg/post_bg.jpg"
catalog:    true
tags:
    - business
---

## 前言

现在所有移动端应用，无论是新闻资讯、大众娱乐，还是即时通讯，充分利用人类是视觉动物的特点，通过大量的图片和视频强化用户对应用的依赖程度。继游戏之后，成为当今社会另一种名副其实的电子毒品。不过这里把研究的点限制在一个特定领域内，也就是主题所说的：即使通讯头像策略。

上面提及其他关于用户体验的领域研究，会考虑和另一位曾经任职网易的用户研究师合作出一些相关文章。

#### 二、类型划分

在即使通讯层面，头像包含两个类型：

- 个人头像
- 群头像
- 其他头像

#### 2.1 技术共性

先说说头像图片的技术共性。现在保存图片的类型主要为：__JPG__、__PNG__、__WEBP__。__JPG__ 是使用历史最长的有损图像压缩格式，体积也算小。

PNG相比JPG更大的优势应该是其无损压缩的能力，但是在缩略图加载的有损压缩用人眼几乎不能辨别的损失，换取更小的文件体积。所以此处PNG对比JPG并不占明显优势。

随后Google推出Webp，用比JPG更小的文件体积， 提供堪比PNG无损压缩的视觉质量。不过，Webp推荐时间较晚，也注定在部分应用或浏览器上存在兼容问题。不过考虑到其非一般的技术优越性，个人认为在浏览器兼容或移动端放弃部分旧终端，是完全值得的。

因此头像图像的文件格式保存上，不考虑兼容性等具体问题，技术选型的优先级如下：Webp>JPG>PNG。

这里提供一下其他的文章供参考：

[WebP 相对于 PNG、JPG 有什么优势？ - Hahn的回答 - 知乎](https://www.zhihu.com/question/27201061/answer/35637827)

[WebP原理和Android支持现状介绍](https://cloud.tencent.com/developer/article/1071597)

#### 2.2 个人头像

个人头像比较容易理解，就是好友自己设置的个性化的头像。个人头像具有比较鲜明的性格特点，能从个人头像的选图推断出好友的性格。只要七大姑八大姨不扯嘴皮子，几乎是爱用啥用啥。所以在业务层面，个人头像应该是应用图片加载内需求最简单的。

拿微信举例，在1920*1080 的Android上布局大小约为50dp\*50dp(推测)，所以在Android的xxhdpi的UI设计大小相当于150px\*150px，iOS的三倍图也是这个规格。

![avatar_1_grid](/img/business/avatar_images_compressing/avatar_1_grid.png)



因此个人图像的大小，完全就是UI布局的实际大小，并且不需要任何 __内边距__。

#### 2.3 群头像

群头像相比个人头像业务略显复杂，和个人头像最大的区别除了内嵌头像数量，还有最大的特点是具有内边距。群头像的排列具有四宫格、九宫格和群自定义类型三种。n宫格的具体头像组合，遵循群主优先或首位进入用户优先。

##### 2.3.1 四宫格头像

4宫格头像和9宫格头像本质没有任何差异，不同的产品经理会有不同的喜好。以下是4宫格的多人排列模式：

![avatars_4_grids](/img/business/avatar_images_compressing/avatars_4_grids.png)

##### 2.3.2 九宫格头像

以下是9宫格的多人排列模式：

![avatars_9_grids](/img/business/avatar_images_compressing/avatars_9_grids.png)

##### 2.3.3 群自定义类型

除了类似微信的n宫格模式，还有一只是QQ那种群头像自定义模式。群主可以自行上传群的头像。

####  2.4 其他头像

其他头像的逻辑，应划分到非自然人头像，例如微信小程序的头像。和个人头像的逻辑没有具体差别，可以完全套用。

## 三、技术谈

上面介绍的内容是面向产品方面的思考，而下面讨论是记录工作经验总结的技术重点。在用户侧看来，头像设置是个简单的不能更简单的功能。但是在从技术的角度看，其中隐藏着海量的技术决策和问题解决方案。因为涉及技术很多，所以这里就选择几个印象深刻的部分进行探讨。

#### 3.1 图像缓存

头像作为一张图片，虽然体积和体积相比其他用户聊天图片较少，但是在好友很多导致头像数量很多的情况下，流量就会积少成多。因此，很多现今的图片加载框架就能发挥一臂之力。在Android端，常用的图片加载框架就是Glide。虽然Glide可选不同的缓存策略，图片压缩配置，但是根据长期的使用经验来说，Glide在头像加载方面真的很不合适。

由于Glide的缓存是其自行管理的，清除缓存只能无差别清除所有缓存。有的时候，好友会有更换头像的操作，更换完成后，本用户的客户端就会留有好友以前旧的头像。这张旧的头像很大可能是不会再展示出来的，但是不能满足根据指定哈希值失效对应的图片，所以这张图片会一直存储在磁盘里，导致缓存越来越大。这个问题可能通过配置Glide 的DiskLruCache大小做一定的保护，不过这个方案毕竟治标不治本，没有从根本的、更细粒度地控制缓存。

这个问题也有其他用户的在Github上提过相关的issue，作者明确回复不支持相关功能。

#### 3.2 群头像合成

群头像合成既可以在客户端，也可以在服务端进行。为了较少重新生成的次数，可以向微信学习，只要群组内前9为用户没有进出群聊，该群头像不会更新。这里需要明确说明的是，即使这9位用户头像进行了修改，群头像也不会失效。这样可以大大减少新群头像生成的次数。

而根据个人的工作经验，生成的地点最好在服务端。假设通过移动端生成满9人的群头像，移动端就需要先发出9个并发的HTTP请求分别获取用户的头像。这些头像最小也是150px\*150px。所以总共下载9张150px\*150px的图片，再压缩处理9张图片，才能生成一张群头像。为了一个群头像发出9次网络访问，消耗9倍的流量，还要耗费移动端本地处理器性能才能完成一张图。

扩大范围来说有一万个用户，每个用户有10个群的群头像需要生成，即使群里面部分个人用户的头像重叠并已被缓存，粗劣估算也需要：1万个用户\*10个群\*4张每个群=40万次的网络访问。如果把生成操作全部放在客户端完成，那么客户端只需要根据群ID，获取10万次即可保证所有群头像加载完成。

宽且，在客户端生成群头像的方面，这里还没有把用户清除缓存、客户端重复获取个人头像、性能消耗等等问题。所以不管怎么，不在极端技术不能实现的情况下，不要考虑移动端完成群头像合成工作。

#### 3.3 缓存失效机制

对大多数图片加载框架来说，通过HTTP地址获取图片成功后，只要缓存没被清理，图片框架就不会访问网络检查图片是否有更新。只访问一次网络能避免冗余的网络更新检查带来的流量和电量负担，但失去了定时甚至实时更新的能力。而每次加载同一张图片，都通过HEADER的方式检查是否需要下载新图片，能减少开发者操控缓存的劳动，而增加了流量和耗电量。

如果想做到两全其美，最好把外部的哈希值和图片的HTTP地址组合为元组，只要其中任意参数没有变化，就不需要更新图片。通过其他接口的网络长链接、长轮询，通知该元组变化，再进行对应的新图片拉取。一般需要开发者封装图片加载框架实现此目标，例如Glide的GlideUrl和ObjectKey