I"c#<h1 id="类加载">类加载</h1>

<p>Java类通过编译生成对应.class文件，JVM根据运行需要把类从文件加载到内存并创建实例，ClassLoader负责完成这个加载任务。有了ClassLoader，Java运行时系统不需要知道文件与文件系统的设置。</p>

<p>正是因为Java类必须由某个类加载器装入到内存，我们也可以在运行时才指定类文件。</p>

<h1 id="java中的三个默认类加载器">Java中的三个默认类加载器</h1>

<p>除了Bootstrap ClassLoader，其他类装载器都有父装载器（parent class loader），且ExtClassLoader和AppClassLoader均继承ClassLoader类。</p>

<ul>
  <li>
    <p>引导（Bootstrap）类加载器。由原生代码（C++）编写，不继承自<code class="highlighter-rouge">java.lang.ClassLoader</code>。负责加载存储在<code class="highlighter-rouge">&lt;JAVA_HOME&gt;/jre/lib</code>目录中的核心Java库。</p>
  </li>
  <li>
    <p>扩展（Extensions）类加载器。用来在<code class="highlighter-rouge">&lt;JAVA_HOME&gt;/jre/lib/ext</code>或<code class="highlighter-rouge">java.ext.dirs</code>指明的目录中加载 Java扩展库，Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。该类由<code class="highlighter-rouge">sun.misc.Launcher$ExtClassLoader</code>实现。</p>
  </li>
  <li>
    <p>应用（Application）类加载器。根据 Java应用程序的类路径<code class="highlighter-rouge">（java.class.path或CLASSPATH环境变量）</code>来加载类。一般Java类都由它完成加载，可以通过 <code class="highlighter-rouge">ClassLoader.getSystemClassLoader()</code>来获取。该类由<code class="highlighter-rouge">sun.misc.Launcher$AppClassLoader</code>实现。</p>
  </li>
</ul>

<p><img src="/img/java/classloader.png" alt="img" /></p>

<p><strong>通过Bootstrap ClassLoader加载的库</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="no">URL</span><span class="o">[]</span> <span class="n">urls</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher</span><span class="o">.</span><span class="na">getBootstrapClassPath</span><span class="o">().</span><span class="na">getURLs</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="no">URL</span> <span class="n">url</span> <span class="o">:</span> <span class="n">urls</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">toExternalForm</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>结果</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/resources.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/sunrsasign.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/jsse.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/jce.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/charsets.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/jfr.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/classes
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="classloader类加载">ClassLoader类加载</h1>

<p>ClassLoader通过双亲委托的方式来搜索类，而双亲委托是一种委派思想。当ClassLoader加载类的时候，ClassLoader会委托其父加载器去完成：</p>

<ul>
  <li>
    <p>AppClassLoader想加载指定类；</p>
  </li>
  <li>首先让Bootstrap ClassLoader尝试加载该类；</li>
  <li>加载失败交给ExtClassLoader尝试；</li>
  <li>ExtClassLoader失败还给AppClassLoader自行加载；</li>
</ul>

<p>如果三个默认类加载器都加载失败，工作只能还给发起工作的ClassLoader，由这个加载器自行选择加载类文件系统或URL。</p>

<p>所有加载器都无法加载这个类，抛出ClassNotFoundException异常。若按照这个步骤加载成功，类加载器把这个类载入内存，初始化并返回实例。</p>

<h1 id="双亲委托">双亲委托</h1>

<p>使用双亲委托是为了两个目的：运行安全和避免重复加载。</p>

<p>后者容易理解，类已经被父加载器加载的话，子加载器没有必要再次重复加载；对于前者，有些系统级的类涉及到整个JVM的运行安全，仅能通过Bootstrap ClassLoader加载。如果不使用双亲委托，使用自定义的类来动态替代Java核心定义类型，后续系统将完全处于危险和混乱之中。</p>

<h1 id="classloader层次结构">ClassLoader层次结构</h1>

<p>先编写类加载的代码，其中<code class="highlighter-rouge">Man</code>是一个自行定义的普通类</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kd">final</span> <span class="nc">String</span> <span class="n">dir</span> <span class="o">=</span> <span class="s">"file:/Users/phantomVK/repositories/intelliJ/cl/src"</span><span class="o">;</span>
<span class="nc">URLClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLClassLoader</span><span class="o">(</span><span class="k">new</span> <span class="no">URL</span><span class="o">[]</span> <span class="o">{</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="n">dir</span><span class="o">)</span> <span class="o">});</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="s">"com.phantomvk.Man"</span><span class="o">);</span>
<span class="nc">ClassLoader</span> <span class="n">classLoader</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>

<span class="k">while</span> <span class="o">(</span><span class="n">classLoader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classLoader</span><span class="o">);</span>
    <span class="n">classLoader</span> <span class="o">=</span> <span class="n">classLoader</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
<span class="o">}</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classLoader</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>加载Man的类加载器显示结果</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>sun.misc.Launcher$AppClassLoader@4b67cf4d
sun.misc.Launcher$ExtClassLoader@61bbe9ba
null
</pre></td></tr></tbody></table></code></pre></div></div>

<p>加载层次：</p>

<ul>
  <li>Man类的类加载器是AppClassLoader</li>
  <li>AppClassLoader的类加载器是ExtClassLoader</li>
  <li>ExtClassLoader的类加载器是BootstrapLoader。</li>
</ul>

<p>BootstrapLoader由C++实现而不是Java，不运行在JVM中。所以ExtClassLoader的类加载器没法显示BootstrapLoader的引用地址，只能显示null。</p>

<h1 id="自定义classloader">自定义ClassLoader</h1>

<p>自定义ClassLoader比较简单</p>

<ul>
  <li>只需要继承ClassLoader父类；</li>
  <li>仅重写Class&lt;?&gt; findClass(String name)方法，查找并返回这个类；</li>
  <li>剩余的加载过程由父类完成，无需手动处理。</li>
</ul>

:ET