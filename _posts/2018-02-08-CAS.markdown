---
layout:     post
title:      "Java CAS底层实现详解"
date:       2017-02-08
author:     "phantomVK"
header-img: "img/main_img.jpg"
catalog:    true
tags:
    - Java
---

## 前言

这次深入介绍`CAS`在`JDK`中如何实现，填补[Java源码系列(7) -- AtomicInteger](https://phantomvk.github.io/2018/01/17/AtomicInteger/)没有详细说明的`Unsafe`和`CAS`。从高层调用起，经历`JDK`和`JNI`，最终到`asm`汇编调用处理器CAS指令集，带你浏览整个流程实现。

阅读需扎实`Java`基本功，了解或能看懂`JNI`和`C`。而汇编没学习也没有关系，文章参考链接附带本文涉及所有汇编知识点。

## 一、Unsafe


在Java中，`compareAndSetInt`在`Unsafe`类中:

JDK8该方法名为`compareAndSwapInt`

```java
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

JDK9命名为`compareAndSetInt`

```
public final native boolean compareAndSetInt(Object var1, long var2, int var4, int var5);
```

下面我们全部用JDK9作为前提。如果你看JDK8也没关系，我特意检查了一下JDK8u的源码，所有JVM源码文件路径通用，只是方法签名稍有差别，实现甚至方法所在行数基本一致。


我们直接看该方法的原生实现，该方法对应`unsafe.cpp`文件的1198行，文件路径`jdk9/hotspot/src/share/vm/prims/`。

下面`unsafe.cpp`大概尾部有个静态数组，保存了多个方法：

```cpp
static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
    ......
    
    {CC "compareAndSetInt",   CC "(" OBJ "J""I""I"")Z",  FN_PTR(Unsafe_CompareAndSetInt)},
    {CC "compareAndSetLong",  CC "(" OBJ "J""J""J"")Z",  FN_PTR(Unsafe_CompareAndSetLong)},
    {CC "compareAndExchangeObject", CC "(" OBJ "J" OBJ "" OBJ ")" OBJ, FN_PTR(Unsafe_CompareAndExchangeObject)},
    {CC "compareAndExchangeInt",  CC "(" OBJ "J""I""I"")I", FN_PTR(Unsafe_CompareAndExchangeInt)},
    {CC "compareAndExchangeLong", CC "(" OBJ "J""J""J"")J", FN_PTR(Unsafe_CompareAndExchangeLong)},
    ......
}
```

从查找对应关系我们知道`compareAndSetInt`是1031行的`Unsafe_CompareAndSetInt`：

```cpp
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *)index_oop_from_field_offset_long(p, offset);

  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
} UNSAFE_END
```

`Unsafe_CompareAndSetInt`执行流程：

 - `obj`是调用的`AtomicInteger`对象，获取`obj`在内存中OOP实例`p`
 - 根据成员变量`value`反射后计算出的内存偏移值`offset`，去内存中获得对应指针`addr`
 - 获得变换值`x`、指针`addr`、原值`e`三个参数后，调用`Atomic::cmpxchg(x, addr, e)`

## 二、Atomic::cmpxchg

该方法在`jdk9/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86`的100行。实际调用了asm汇编。

```cpp
inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value, cmpxchg_memory_order order) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}
```

`cmpxchg`方法签名：

 - `exchange_value`对应变换值`x`
 - `dest`对应指针`addr`
 - `compare_value`对应原值`e`
 - `order`是JDK9中新加的，JDK8u没有该形参

方法is_MP()实现在`jdk9/hotspot/src/share/vm/runtime/os.hpp`的206行：

```c
int mp = os::is_MP();
```

`is_MP()`用于获取当前系统处理器核心数，如果`_processor_count`在引导过程尚未初始化，就默认假设其是多处理器以保证线程安全。

```cpp
static int _processor_count;                // number of processors
static int _initial_active_processor_count; // number of active processors during initialization.

// Interface for detecting multiprocessor system
static inline bool is_MP() {
  // During bootstrap if _processor_count is not yet initialized
  // we claim to be MP as that is safest. If any platform has a
  // stub generator that might be triggered in this phase and for
  // which being declared MP when in fact not, is a problem - then
  // the bootstrap routine for the stub generator needs to check
  // the processor count directly and leave the bootstrap routine
  // in place until called after initialization has ocurred.
  return (_processor_count != 1) || AssumeMP;
}
```

获取成功后把核心数保存在整形值`mp`中，实际起到布尔值的作用，为0意味系统是单处理器系统，大于0是多处理器系统，并作为实参调起宏定义`LOCK_IF_MP(mp)`：

```cpp
// Adding a lock prefix to an instruction on MP machine
#define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "
```

宏定义用`"cmp $0, " #mp "`检查 __核心是否为单核__：

 - 是：跳到`1f`，执行CPU指令`cmpxchgl %1,(%3)`。`1f`的意思是`1after`，参看[参考链接6](https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly)
 - 不是：只比单核多一条指令，跳到`1f`前先给总线上锁`lock`，令物理处理器其他核心不能通过总线访存，保证指令操作的原子性

我还注意到一个结构：

```c
__asm__ volatile ("": : :"memory")
```

这个结构告诉编译器层添加一个内存障碍，详见[参考链接3](https://stackoverflow.com/questions/14950614/working-of-asm-volatile-memory)：

> Creates a compiler level memory barrier forcing optimizer to not re-order memory accesses across the barrier.

说了这么多，还是不容易理解，毕竟上述代码是C语言混编`asm`，我理解后翻译为伪代码：

```java
/**
 * @param _processor_count processor count
 * @param assumeMP         assume is multiprocessor when is not yet initialized
 * @param compare_value    be comparing
 * @param dest             set as new value if true
 */
private void isMultiProcessCAS(int _processor_count,
                               boolean assumeMP,
                               int compare_value,
                               int dest) {
                          
    if (_processor_count != 1 || assumeMP) {
        lock();
    }
    cmpxchgl(compare_value, dest);
    // Should unlock after cmpxchgl(int, int)???
}
```

在[参考链接12](https://bugs.java.com/view_bug.do?bug_id=8185062)中，已有人提议把`os::is_MP()`的`AssumeMP`永久设为`true`提升性能。且在`2017-10-03`于`JDK10b13`实现，所以上述伪代码可以进一步演进为：

```java
/**
 * @param _processor_count processor count
 * @param compare_value    be comparing
 * @param dest             set as new value if true
 */
private void isMultiProcessCAS(int _processor_count,
                               int compare_value,
                               int dest) {

    if (_processor_count != 1) {
        lock();
    }
    cmpxchgl(compare_value, dest);
    // Should unlock after cmpxchgl(int, int)???
}
```

到这里Java CAS底层实现全部讲解完毕。如果还有疑问，下面参考链接应该能给你所有需要的解答。

## 四、参考链接

[1. Java CAS 原理剖析 - 卡巴拉的树 - 掘金](https://juejin.im/post/5a73cbbff265da4e807783f5)

[2. Assembly language je jump function - Stackoverflow](https://stackoverflow.com/questions/1582960/assembly-language-je-jump-function)

[3. Working of __asm__ __volatile__ (“” : : : “memory”) - Stackoverflow](https://stackoverflow.com/questions/14950614/working-of-asm-volatile-memory)

[4. JNI: converting unsigned int to jint - Stackoverflow](https://stackoverflow.com/questions/8012450/jni-converting-unsigned-int-to-jint)

[5. CMPXCHG - Compare and Exchange](http://faydoc.tripod.com/cpu/cmpxchg.htm)

[6. 1b and 1f in GNU assembly - Stackoverflow](https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly)

[7. cmp je/jg how they work in assembly - Stackoverflow](https://stackoverflow.com/questions/12665289/cmp-je-jg-how-they-work-in-assembly)

[8. Intel x86 JUMP quick reference](http://www.unixwiz.net/techtips/x86-jumps.html)

[9. 朴素linux: 内联汇编  - Github](https://github.com/1184893257/simplelinux/blob/master/inlineasm.md)

[10. 内联汇编 - 从头开始 - IBM](https://www.ibm.com/developerworks/cn/aix/library/au-inline_assembly/index.html)

[11. 什么是桩代码（Stub）- 知乎](https://www.zhihu.com/question/24844900)

[12. JDK-8185062 : Set AssumeMP to true and deprecate the flag](https://bugs.java.com/view_bug.do?bug_id=8185062)


