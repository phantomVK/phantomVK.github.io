I""=<h2 id="背景">背景</h2>

<p>滑动退出最早出现在 <strong>iOS7</strong>，是系统提供的标准功能，一直沿用到现在。</p>

<p>对 <strong>Android</strong>  来说，更多是因为iOS出现该功能，产品经理为统一移动终端的 <strong>user experience</strong> 而跟进。相比 iOS在系统层完美的实现方式，Android无论用哪种方式，都需要在内存、处理器性能、流畅性之一作出牺牲。</p>

<h2 id="方案">方案</h2>

<p>现时讨论最多的两种方案是：</p>

<ul>
  <li>截屏图片模仿透明背景；</li>
  <li>Window及Activity透明处理；</li>
</ul>

<h4 id="截屏图片">截屏图片</h4>

<p><strong>截屏图片</strong> 是截取当前屏幕的图片，打开新界面的时候传递给新界面。新界面把该图片作为底下一层界面的透视图。很多技术不错的同行提起过这种方案，不过这种方案不具备可用性。</p>

<p>Android图片多使用 <strong>RGB565</strong> 内存定义，按照流行屏幕尺寸 <strong>1920*1080</strong> 宽高各减半算内存占用：</p>

<blockquote>
  <p>(5 + 6 + 5) / 8 *  (1920 / 2) * (1080 / 2) = 1, 036, 800Bytes = 1013KB</p>
</blockquote>

<p>每个页面为保存截图都要占用近1MB内存，那截图时处理器占用，图片传递延迟，有考虑过吗？</p>

<h4 id="window及activity透明处理">Window及Activity透明处理</h4>

<p>如果只能在两个不完美的方案里挑一个，我选这个方案。</p>

<p>流行开源库 <a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a> 也选择这种方案。不过这个工程从 <strong>2018.07.10</strong> 后再也没有维护，在此前提出的问题都没有修复，更不用说，对源码迁移到 <strong>AndroidX</strong> 这种要求。</p>

<p>除了对好些异常没有处理，本身透明逻辑定义的时间点也是有问题的。先看界面正常生命周期：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>I/MainActivity@bc1f0e: onCreate
I/MainActivity@bc1f0e: onStart
I/MainActivity@bc1f0e: onResume

I/MainActivity@bc1f0e: onPause
I/MainActivity@2e5c3a1d: onCreate
I/MainActivity@2e5c3a1d: onStart
I/MainActivity@2e5c3a1d: onResume
I/MainActivity@bc1f0e: onStop

I/MainActivity@2e5c3a1d: onPause
I/MainActivity@2a2ef203: onCreate
I/MainActivity@2a2ef203: onStart
I/MainActivity@2a2ef203: onResume
I/MainActivity@2e5c3a1d: onStop

I/MainActivity@2a2ef203: onPause
I/MainActivity@3d0b6459: onCreate
I/MainActivity@3d0b6459: onStart
I/MainActivity@3d0b6459: onResume
I/MainActivity@2a2ef203: onStop
</pre></td></tr></tbody></table></code></pre></div></div>

<p>以上周期大家都很熟悉，不再赘述。</p>

<p><strong>SwipeBackLayout</strong> 异常生命周期：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>I/DemoActivity@bd11e3a: onCreate
I/DemoActivity@bd11e3a: onStart
I/DemoActivity@bd11e3a: onResume

I/DemoActivity@bd11e3a: onPause
I/DemoActivity@24fbcaab: onCreate
I/DemoActivity@24fbcaab: onStart
I/DemoActivity@24fbcaab: onResume

I/DemoActivity@24fbcaab: onPause
I/DemoActivity@378d89c8: onCreate
I/DemoActivity@378d89c8: onStart
I/DemoActivity@378d89c8: onResume

I/DemoActivity@378d89c8: onPause
I/DemoActivity@20264021: onCreate
I/DemoActivity@20264021: onStart
I/DemoActivity@20264021: onResume

I/DemoActivity@20264021: onPause
I/DemoActivity@2a17ef06: onCreate
I/DemoActivity@2a17ef06: onStart
I/DemoActivity@2a17ef06: onResume
</pre></td></tr></tbody></table></code></pre></div></div>

<p>所有已启动界面！所有已启动界面！在打开新界面后都不会走到 <strong>onStop</strong>，也就是说所有应该在 <strong>onStop</strong> 停止的操作、释放的资源，都没有机会触发。导致的结果是：当打开简单页面数量超过7个，就会出现新页面进场卡顿。</p>

<p>独立调研后，发现我的解决方案没法基于 <strong>SwipeBackLayout</strong> 进行修改。所以实现新开源库 <a href="https://github.com/phantomVK/SlideBack">phantomVK/SlideBack</a> 达到期望技术目标。</p>

<p>新库对 <strong>反射操作</strong>、<strong>页面过度绘制</strong>、<strong>内存占用</strong>，和 <strong>生命周期异常</strong> 修复后的结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>I/MainActivity@3b063dbb: onCreate
I/MainActivity@3b063dbb: onStart
I/MainActivity@3b063dbb: onResume

I/MainActivity@2304ed15: onStop
I/MainActivity@3b063dbb: onPause
I/MainActivity@2941f6d1: onCreate
I/MainActivity@2941f6d1: onStart
I/MainActivity@2941f6d1: onResume

I/MainActivity@3b063dbb: onStop
I/MainActivity@2941f6d1: onPause
I/MainActivity@b2f0dd7: onCreate
I/MainActivity@b2f0dd7: onStart
I/MainActivity@b2f0dd7: onResume

I/MainActivity@2941f6d1: onStop
I/MainActivity@b2f0dd7: onPause
I/MainActivity@238b744d: onCreate
I/MainActivity@238b744d: onStart
I/MainActivity@238b744d: onResume
</pre></td></tr></tbody></table></code></pre></div></div>

<p>和前文日志对比可以发现，新方案只有当前界面的下一级界面生命周期没有走到 <strong>onStop</strong>。具体原因可看 <a href="/2016/12/16/Android_LifeCycle/">透明Activity生命周期变化</a>。优化后界面都能正确释放资源，无论打开多少个新页面，不再有卡顿问题。</p>

<h2 id="改进">改进</h2>

<h4 id="反射优化">反射优化</h4>

<p>反射在Java操作中耗费性能，而且基于应用场景的原因不能在子线程内运行。对此有以下改进，把类方法查找操作放在静态初始化块内完成，后续无需每次使用都查找一次。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TranslucentHelper</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Method</span> <span class="n">sOptionsMethod</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Method</span> <span class="n">sInvokeMethod</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Method</span> <span class="n">sRevokeMethod</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">init</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NoSuchMethodException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">SDK_INT</span> <span class="o">&lt;</span> <span class="no">KITKAT</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

        <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">Activity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredClasses</span><span class="o">();</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="nc">Class</span> <span class="n">c</span> <span class="o">:</span> <span class="n">classes</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"TranslucentConversionListener"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">clz</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">clz</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">SDK_INT</span> <span class="o">&gt;=</span> <span class="no">LOLLIPOP</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sOptionsMethod</span> <span class="o">=</span> <span class="nc">Activity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"getActivityOptions"</span><span class="o">);</span>
            <span class="n">sOptionsMethod</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

            <span class="n">sInvokeMethod</span> <span class="o">=</span> <span class="nc">Activity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"convertToTranslucent"</span><span class="o">,</span> <span class="n">clz</span><span class="o">,</span> <span class="nc">ActivityOptions</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">sInvokeMethod</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">sInvokeMethod</span> <span class="o">=</span> <span class="nc">Activity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"convertToTranslucent"</span><span class="o">,</span> <span class="n">clz</span><span class="o">);</span>
            <span class="n">sInvokeMethod</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">sRevokeMethod</span> <span class="o">=</span> <span class="nc">Activity</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"convertFromTranslucent"</span><span class="o">);</span>
        <span class="n">sRevokeMethod</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="o">....</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="生命周期">生命周期</h4>

<p><a href="https://github.com/phantomVK/SlideBack">phantomVK/SlideBack</a> 比SwipeBackLayout最大优化主要是生命周期的处理，即打开新 <strong>Activity</strong> 时把当前页面的透明背景取消掉。</p>

<p>而最合适的时间点，莫过于在 <strong>startActivityForResult()</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">startActivityForResult</span><span class="o">(</span><span class="nc">Intent</span> <span class="n">intent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">requestCode</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Bundle</span> <span class="n">options</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mManager</span><span class="o">.</span><span class="na">startActivityForResult</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">requestCode</span><span class="o">,</span> <span class="n">options</span><span class="o">);</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">startActivityForResult</span><span class="o">(</span><span class="n">intent</span><span class="o">,</span> <span class="n">requestCode</span><span class="o">,</span> <span class="n">options</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>页面对用户可操作时设置透明：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onResume</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
    <span class="n">mManager</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>个人认为在用户拖动边缘时才设置透明方案不妥当，因为反射对主线程的阻塞，会给用户拖动操作带来迟滞的感觉，最好是界面可见时就具备操作的能力。</p>

<h4 id="其他优化">其他优化</h4>

<ul>
  <li>源码库已迁移并适配 <strong>AndroidX</strong>；</li>
  <li>继承父类为 <strong>AppCompatActivity</strong>；</li>
  <li>内部已捕获异常 <strong>ArrayIndexOutOfBoundsException</strong>；</li>
  <li>使用基于 <strong>Android28</strong> 定制 <strong>ViewDragHelper</strong> 工具类；</li>
  <li>更细致功能启用、停用开关控制，避免冗余内存开销；</li>
  <li>重写 <strong>findViewById</strong> 方法支持泛型；</li>
</ul>
:ET